{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/sheet.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AAPA;;;;;;;AASA,MAAM,QAAQ,qKAAA,CAAA,OAAmB;AAEjC,MAAM,eAAe,qKAAA,CAAA,UAAsB;AAE3C,MAAM,aAAa,qKAAA,CAAA,QAAoB;AAEvC,MAAM,cAAc,qKAAA,CAAA,SAAqB;AAEzC,MAAM,6BAAe,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,EAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,UAAsB;QACrB,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,2JACA;QAED,GAAG,KAAK;QACT,KAAK;;;;;;KAVH;AAaN,aAAa,WAAW,GAAG,qKAAA,CAAA,UAAsB,CAAC,WAAW;AAE7D,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB,oMACA;IACE,UAAU;QACR,MAAM;YACJ,KAAK;YACL,QACE;YACF,MAAM;YACN,OACE;QACJ;IACF;IACA,iBAAiB;QACf,MAAM;IACR;AACF;AAOF,MAAM,6BAAe,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGlC,CAAC,EAAE,OAAO,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpD,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,qKAAA,CAAA,UAAsB;gBACrB,KAAK;gBACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;oBAAE;gBAAK,IAAI;gBACtC,GAAG,KAAK;;oBAER;kCACD,6LAAC,qKAAA,CAAA,QAAoB;wBAAC,WAAU;;0CAC9B,6LAAC,+LAAA,CAAA,IAAC;gCAAC,WAAU;;;;;;0CACb,6LAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,aAAa,WAAW,GAAG,qKAAA,CAAA,UAAsB,CAAC,WAAW;AAE7D,MAAM,cAAc,CAAC,EACnB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,oDACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,YAAY,WAAW,GAAG;AAE1B,MAAM,cAAc,CAAC,EACnB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,QAAoB;QACnB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,yCAAyC;QACtD,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG,qKAAA,CAAA,QAAoB,CAAC,WAAW;AAEzD,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,cAA0B;QACzB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG,qKAAA,CAAA,cAA0B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/button.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAEA;;;;;;AAEA,MAAM,iBAAiB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACvB,4VACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OAAO;YACP,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;QACR;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AASF,MAAM,uBAAS,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAC5B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,KAAK,EAAE,GAAG,OAAO,EAAE;IACxD,MAAM,OAAO,UAAU,mKAAA,CAAA,OAAI,GAAG;IAC9B,qBACE,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,eAAe;YAAE;YAAS;YAAM;QAAU;QACxD,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,OAAO,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/calendar.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n"],"names":[],"mappings":";;;;AAGA;AAAA;AACA;AAEA;AACA;AAPA;;;;;;AAWA,SAAS,SAAS,EAChB,SAAS,EACT,UAAU,EACV,kBAAkB,IAAI,EACtB,GAAG,OACW;IACd,qBACE,6LAAC,iKAAA,CAAA,YAAS;QACR,iBAAiB;QACjB,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,OAAO;QACrB,YAAY;YACV,QAAQ;YACR,OAAO;YACP,SAAS;YACT,eAAe;YACf,KAAK;YACL,YAAY,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACX,CAAA,GAAA,qIAAA,CAAA,iBAAc,AAAD,EAAE;gBAAE,SAAS;YAAU,IACpC;YAEF,qBAAqB;YACrB,iBAAiB;YACjB,OAAO;YACP,UAAU;YACV,WACE;YACF,KAAK;YACL,MAAM;YACN,KAAK,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACJ,CAAA,GAAA,qIAAA,CAAA,iBAAc,AAAD,EAAE;gBAAE,SAAS;YAAQ,IAClC;YAEF,eAAe;YACf,cACE;YACF,WAAW;YACX,aACE;YACF,cAAc;YACd,kBACE;YACF,YAAY;YACZ,GAAG,UAAU;QACf;QACA,YAAY;YACV,UAAU,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,iBAChC,6LAAC,uNAAA,CAAA,cAAW;oBAAC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,WAAW;oBAAa,GAAG,KAAK;;;;;;YAE7D,WAAW,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,iBACjC,6LAAC,yNAAA,CAAA,eAAY;oBAAC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,WAAW;oBAAa,GAAG,KAAK;;;;;;QAEhE;QACC,GAAG,KAAK;;;;;;AAGf;KAvDS;AAwDT,SAAS,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/popover.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,UAAU,sKAAA,CAAA,OAAqB;AAErC,MAAM,iBAAiB,sKAAA,CAAA,UAAwB;AAE/C,MAAM,+BAAiB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,sKAAA,CAAA,SAAuB;kBACtB,cAAA,6LAAC,sKAAA,CAAA,UAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,sKAAA,CAAA,UAAwB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB;AAGF,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAI3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,OAAmB;QAClB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB;QAC9B,GAAG,KAAK;;;;;;;AAGb,MAAM,WAAW,GAAG,oKAAA,CAAA,OAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;;AAEA,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAC3B,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAO,EAAE;IAC9B,qBACE,6LAAC;QACC,MAAM;QACN,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,kYACA;QAEF,KAAK;QACJ,GAAG,KAAK;;;;;;AAGf;;AAEF,MAAM,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/separator.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n"],"names":[],"mappings":";;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,0BAAY,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAI/B,CACE,EAAE,SAAS,EAAE,cAAc,YAAY,EAAE,aAAa,IAAI,EAAE,GAAG,OAAO,EACtE,oBAEA,6LAAC,wKAAA,CAAA,OAAuB;QACtB,KAAK;QACL,YAAY;QACZ,aAAa;QACb,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,sBACA,gBAAgB,eAAe,mBAAmB,kBAClD;QAED,GAAG,KAAK;;;;;;;AAIf,UAAU,WAAW,GAAG,wKAAA,CAAA,OAAuB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions/create-checkout-session.ts"],"sourcesContent":["\"use server\";\n\nimport type { Property } from '@/types';\nimport { headers } from 'next/headers';\nimport Stripe from 'stripe';\n\n// Ensure Stripe secret key is set in environment variables\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\nif (!stripeSecretKey) {\n  throw new Error('STRIPE_SECRET_KEY is not set in environment variables.');\n}\n\nconst stripe = new Stripe(stripeSecretKey);\n\ninterface CreateCheckoutSessionInput {\n  property: Property;\n  checkInDate: string; // ISO string format\n  checkOutDate: string; // ISO string format\n  numberOfGuests: number;\n  totalPrice: number; // FINAL price in dollars (after discount)\n  numberOfNights: number;\n  // Optional guest info if available upfront\n  guestFirstName?: string;\n  guestLastName?: string;\n  guestEmail?: string; // Pass guest email if available\n  // Optional coupon info\n  appliedCouponCode?: string;\n  discountPercentage?: number;\n}\n\nexport async function createCheckoutSession(input: CreateCheckoutSessionInput) {\n  const {\n    property,\n    checkInDate,\n    checkOutDate,\n    numberOfGuests,\n    totalPrice, // This is the final price AFTER discount\n    numberOfNights,\n    guestEmail, // Capture guest email if provided\n    guestFirstName,\n    guestLastName,\n    appliedCouponCode, // Get coupon code\n    discountPercentage, // Get discount percentage\n  } = input;\n\n  const origin = headers().get('origin') || 'http://localhost:9002'; // Default for local dev\n\n  // Calculate number of extra guests\n  const numberOfExtraGuests = Math.max(0, numberOfGuests - property.baseOccupancy);\n\n  // --- Prepare metadata ---\n  const metadata: Stripe.MetadataParam = {\n    propertyId: property.id,\n    propertyName: property.name,\n    checkInDate: checkInDate,\n    checkOutDate: checkOutDate,\n    numberOfGuests: String(numberOfGuests),\n    numberOfNights: String(numberOfNights),\n    totalPrice: String(totalPrice), // Final price paid\n    cleaningFee: String(property.cleaningFee),\n    pricePerNight: String(property.pricePerNight),\n    baseOccupancy: String(property.baseOccupancy),\n    extraGuestFee: String(property.extraGuestFee),\n    numberOfExtraGuests: String(numberOfExtraGuests),\n    guestFirstName: guestFirstName || '',\n    guestLastName: guestLastName || '',\n    // userId: loggedInUserId || '', // Add user ID if available\n  };\n\n  // Add coupon info to metadata if applied\n  if (appliedCouponCode && discountPercentage !== undefined) {\n    metadata.appliedCouponCode = appliedCouponCode;\n    metadata.discountPercentage = String(discountPercentage);\n    // Optionally, calculate and add original subtotal and discount amount\n    // const subtotalBeforeDiscount = (property.pricePerNight * numberOfNights) + (property.extraGuestFee * numberOfExtraGuests * numberOfNights) + property.cleaningFee;\n    // const discountAmount = subtotalBeforeDiscount * (discountPercentage / 100);\n    // metadata.subtotalBeforeDiscount = String(subtotalBeforeDiscount);\n    // metadata.discountAmount = String(discountAmount);\n  }\n\n  // --- Construct Success URL with parameters for simulation ---\n  const successUrlParams = new URLSearchParams({\n    session_id: '{CHECKOUT_SESSION_ID}', // Stripe replaces this token\n    // Add params needed for simulation (encode dates)\n    propId: property.id,\n    checkIn: checkInDate,\n    checkOut: checkOutDate,\n    guests: String(numberOfGuests),\n    nights: String(numberOfNights),\n    total: String(totalPrice), // Final price\n    // Include coupon info if applied\n    ...(appliedCouponCode && { coupon: appliedCouponCode }),\n    ...(discountPercentage !== undefined && { discount: String(discountPercentage) }),\n  });\n  const success_url = `${origin}/booking/success?${successUrlParams.toString()}`;\n  const cancel_url = `${origin}/booking/cancel?property_slug=${property.slug}`;\n\n  try {\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [\n        {\n          price_data: {\n            currency: 'usd',\n            product_data: {\n              name: `${property.name} (${numberOfNights} nights, ${numberOfGuests} guests)${appliedCouponCode ? ` - Coupon: ${appliedCouponCode}` : ''}`, // Add coupon info to name\n              description: `Booking from ${new Date(checkInDate).toLocaleDateString()} to ${new Date(checkOutDate).toLocaleDateString()}.`,\n              images: [property.images.find(img => img.isFeatured)?.url || property.images[0]?.url || ''], // Use featured or first image\n            },\n            // Ensure totalPrice is converted to cents correctly\n            unit_amount: Math.round(totalPrice * 100), // Use final price\n          },\n          quantity: 1,\n        },\n      ],\n      mode: 'payment',\n      success_url: success_url, // Use the constructed URL\n      cancel_url: cancel_url,\n       // Include customer email if available, helps Stripe populate customer info\n      customer_email: guestEmail, // Pass guest email to Stripe\n      phone_number_collection: { enabled: true,},\n      // Pass necessary booking details in metadata for the webhook\n      metadata: metadata, // Pass the prepared metadata\n       // payment_intent_data: {\n      //   capture_method: 'automatic', // Or 'manual' if you capture later\n      // },\n    });\n\n    if (!session.id) {\n        throw new Error('Failed to create Stripe session.');\n    }\n\n    return { sessionId: session.id };\n  } catch (error) {\n    console.error('Error creating Stripe Checkout session:', error);\n    // Return a structured error\n    return { error: `Failed to create checkout session: ${error instanceof Error ? error.message : String(error)}` };\n  }\n}"],"names":[],"mappings":";;;;;IA8BsB","debugId":null}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/bookingService.ts"],"sourcesContent":["// src/services/bookingService.ts\n'use server'; // Mark this module for server-side execution\n\nimport {\n  collection,\n  addDoc,\n  doc,\n  getDoc,\n  updateDoc,\n  query,\n  where,\n  getDocs,\n  serverTimestamp as clientServerTimestamp, // Rename client timestamp\n  Timestamp as ClientTimestamp, // Rename client timestamp\n  writeBatch as clientWriteBatch, // Rename client batch\n  setDoc as clientSetDoc, // Rename client setDoc\n  QueryConstraint,\n  limit,\n  documentId, // Import documentId for querying by ID\n} from 'firebase/firestore';\nimport { z } from 'zod';\nimport { db } from '@/lib/firebase'; // **** Use Client SDK Firestore instance ****\n// import { dbAdmin } from '@/lib/firebaseAdmin'; // No longer needed\nimport type { Booking, Availability, Property, SerializableTimestamp } from '@/types'; // Import SerializableTimestamp\nimport { differenceInCalendarDays, eachDayOfInterval, format, parse, subDays, startOfMonth, endOfMonth, parseISO } from 'date-fns';\nimport { updateAirbnbListingAvailability, updateBookingComListingAvailability, getPropertyForSync } from './booking-sync';\n\n// Define the structure for creating a booking\n// Aligning pricing with the updated Booking type\n// Export this type so it can be used by the simulation action\nexport type CreateBookingData = Omit<Booking,\n  'id' |\n  'checkInDate' |\n  'checkOutDate' |\n  'createdAt' |\n  'updatedAt' |\n  'paymentInfo' |\n  'pricing' // Pricing structure will be derived but needs explicit fields\n> & {\n  checkInDate: string; // ISO String for input\n  checkOutDate: string; // ISO String for input\n  pricing: { // Explicitly define expected input for pricing calc\n    baseRate: number;\n    numberOfNights: number;\n    cleaningFee: number;\n    extraGuestFee?: number; // From property at time of booking\n    numberOfExtraGuests?: number; // Calculated based on form input\n    accommodationTotal: number; // New field for base + extra guests cost\n    subtotal: number; // New field for accommodation + cleaning\n    taxes?: number; // Still optional\n    discountAmount?: number; // Optional: Amount discounted via coupon\n    total: number; // Final total calculated by the form/client\n  };\n  appliedCouponCode?: string; // Optional: Store the applied coupon code\n  paymentInput: {\n    stripePaymentIntentId: string;\n    amount: number;\n    status: string;\n  };\n};\n\n\n// Define Zod schema for validation - Updated pricing schema\nconst CreateBookingDataSchema = z.object({\n  propertyId: z.string().min(1, { message: 'Property ID is required.' }),\n  guestInfo: z.object({\n    firstName: z.string().min(1, { message: 'Guest first name is required.' }),\n    lastName: z.string().optional(),\n    email: z.string().email({ message: 'Invalid guest email address.' }),\n    phone: z.string().optional(),\n    address: z.string().optional(),\n    city: z.string().optional(),\n    state: z.string().optional(),\n    country: z.string().optional(),\n    zipCode: z.string().optional(),\n    userId: z.string().optional(),\n  }).passthrough(),\n   // Accept ISO string dates for validation\n  checkInDate: z.string().refine(val => !isNaN(Date.parse(val)), { message: 'Invalid check-in date format.' }),\n  checkOutDate: z.string().refine(val => !isNaN(Date.parse(val)), { message: 'Invalid check-out date format.' }),\n  numberOfGuests: z.number().int().positive({ message: 'Number of guests must be positive.' }),\n  pricing: z.object({ // Updated pricing validation\n    baseRate: z.number().nonnegative({ message: 'Base rate cannot be negative.' }), // Allow 0 for free stays? Adjusted to nonnegative\n    numberOfNights: z.number().int().positive({ message: 'Number of nights must be positive.' }),\n    cleaningFee: z.number().nonnegative({ message: 'Cleaning fee cannot be negative.' }),\n    extraGuestFee: z.number().nonnegative({ message: 'Extra guest fee cannot be negative.' }).optional(),\n    numberOfExtraGuests: z.number().int().nonnegative({ message: 'Number of extra guests cannot be negative.' }).optional(),\n    accommodationTotal: z.number().nonnegative({ message: 'Accommodation total cannot be negative.' }), // Adjusted to nonnegative\n    subtotal: z.number().nonnegative({ message: 'Subtotal cannot be negative.' }), // Adjusted to nonnegative\n    taxes: z.number().nonnegative({ message: 'Taxes cannot be negative.' }).optional(),\n    discountAmount: z.number().nonnegative({ message: 'Discount amount cannot be negative.' }).optional(),\n    total: z.number().nonnegative({ message: 'Total price cannot be negative.' }), // Adjusted to nonnegative\n  }).passthrough(),\n  appliedCouponCode: z.string().optional(), // Validate optional coupon code\n  status: z.enum(['pending', 'confirmed', 'cancelled', 'completed']).optional(),\n  paymentInput: z.object({\n    stripePaymentIntentId: z.string().min(1, { message: 'Stripe Payment Intent ID is required.' }),\n    amount: z.number().nonnegative({ message: 'Payment amount cannot be negative.' }), // Allow 0 for free/fully discounted? Adjusted to nonnegative\n    status: z.string().min(1, { message: 'Payment status is required.' }),\n  }).passthrough(),\n  notes: z.string().optional(),\n  source: z.string().optional(),\n  externalId: z.string().optional(),\n}).refine(data => new Date(data.checkOutDate) > new Date(data.checkInDate), {\n  message: 'Check-out date must be after check-in date.',\n  path: ['checkOutDate'],\n}).refine(data => { // Ensure total matches calculated price, allowing for minor float issues\n    const calculatedTotal = (data.pricing.subtotal ?? 0) + (data.pricing.taxes ?? 0) - (data.pricing.discountAmount ?? 0);\n    // Allow for small floating point differences (e.g., $0.01)\n    return Math.abs(calculatedTotal - data.pricing.total) < 0.01;\n}, {\n    message: 'Calculated total does not match provided total price.',\n    path: ['pricing.total'],\n});\n\n\n/**\n * Creates a new booking document in Firestore using the Client SDK.\n * Calls updatePropertyAvailability (which now also uses the Client SDK) upon success.\n */\nexport async function createBooking(rawBookingData: CreateBookingData): Promise<string> {\n   const paymentIntentId = rawBookingData?.paymentInput?.stripePaymentIntentId || 'N/A';\n   console.log(`--- [createBooking] Function called ---`);\n   console.log(`[createBooking] Received raw data for Payment Intent [${paymentIntentId}]`);\n\n   let bookingData: z.infer<typeof CreateBookingDataSchema>;\n\n   // Zod Validation\n   console.log(`[createBooking] Starting Zod validation for Payment Intent [${paymentIntentId}]...`);\n   const validationResult = CreateBookingDataSchema.safeParse(rawBookingData);\n   if (!validationResult.success) {\n     const errorMessages = validationResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');\n     const validationError = new Error(`Invalid booking data: ${errorMessages}`);\n     console.error(`❌ [createBooking] Validation Error for Payment Intent [${paymentIntentId}]:`, validationError.message);\n     throw validationError;\n   }\n   bookingData = validationResult.data;\n   console.log(`[createBooking] Data passed validation for Payment Intent [${paymentIntentId}]`);\n\n\n  try {\n     console.log(`[createBooking] Entered main try block for Payment Intent [${paymentIntentId}]`);\n     const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db' for booking creation\n\n     // Data Transformation\n     console.log(`[createBooking] Transforming data for Firestore for Payment Intent [${paymentIntentId}]...`);\n     const checkInDate = new Date(bookingData.checkInDate); // Parse ISO string\n     const checkOutDate = new Date(bookingData.checkOutDate); // Parse ISO string\n     const checkInTimestamp = ClientTimestamp.fromDate(checkInDate); // Use Client Timestamp\n     const checkOutTimestamp = ClientTimestamp.fromDate(checkOutDate); // Use Client Timestamp\n\n     const paymentInfo: Booking['paymentInfo'] = {\n       stripePaymentIntentId: bookingData.paymentInput.stripePaymentIntentId,\n       amount: bookingData.paymentInput.amount,\n       status: bookingData.paymentInput.status,\n       paidAt: bookingData.paymentInput.status === 'succeeded' || bookingData.paymentInput.status === 'paid'\n         ? ClientTimestamp.now() // Use Client Timestamp\n         : null,\n     };\n\n     // Remove paymentInput before creating the main docData\n     const { paymentInput, ...restOfBookingData } = bookingData;\n\n     // Construct the final booking document data, including the updated pricing structure\n     const docData: Omit<Booking, 'id'> = {\n         ...restOfBookingData,\n         checkInDate: checkInTimestamp,\n         checkOutDate: checkOutTimestamp,\n         pricing: { // Use the validated pricing object\n             baseRate: restOfBookingData.pricing.baseRate,\n             numberOfNights: restOfBookingData.pricing.numberOfNights,\n             cleaningFee: restOfBookingData.pricing.cleaningFee,\n             extraGuestFee: restOfBookingData.pricing.extraGuestFee,\n             numberOfExtraGuests: restOfBookingData.pricing.numberOfExtraGuests,\n             accommodationTotal: restOfBookingData.pricing.accommodationTotal,\n             subtotal: restOfBookingData.pricing.subtotal,\n             taxes: restOfBookingData.pricing.taxes ?? 0,\n             discountAmount: restOfBookingData.pricing.discountAmount, // Include discount amount\n             total: restOfBookingData.pricing.total,\n         },\n         appliedCouponCode: restOfBookingData.appliedCouponCode, // Include applied coupon code\n         paymentInfo: paymentInfo,\n         createdAt: clientServerTimestamp(), // Use Client serverTimestamp\n         updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n         status: restOfBookingData.status || 'confirmed', // Default status to 'confirmed'\n     };\n\n     // Log the prepared data for debugging\n     console.log(`[createBooking] Firestore Doc Data Prepared for Payment Intent [${paymentIntentId}]:`, JSON.stringify({ ...docData, checkInDate: `Timestamp(${checkInDate.toISOString()})`, checkOutDate: `Timestamp(${checkOutDate.toISOString()})`, paidAt: docData.paymentInfo.paidAt ? `Timestamp(${(docData.paymentInfo.paidAt as ClientTimestamp).toDate().toISOString()})` : null, createdAt: 'ServerTimestamp', updatedAt: 'ServerTimestamp' }, null, 2));\n\n\n     // Firestore Operation (Client SDK)\n     console.log(`[createBooking] Attempting to add booking document to Firestore (Client SDK) for Payment Intent [${paymentIntentId}]...`);\n     const docRef = await addDoc(bookingsCollection, docData);\n     const bookingId = docRef.id;\n     console.log(`✅ [createBooking] Booking document created successfully! ID: ${bookingId} for Payment Intent [${paymentIntentId}]`);\n\n     // --- Update Property Availability (Client SDK) ---\n     console.log(`[createBooking] Triggering local availability update (Client SDK) for property ${bookingData.propertyId}, booking ${bookingId}`);\n     try {\n       await updatePropertyAvailability(bookingData.propertyId, checkInDate, checkOutDate, false); // Using Client SDK function\n       console.log(`✅ [createBooking] Successfully finished update call for local availability (Client SDK) for property ${bookingData.propertyId}, booking ${bookingId}.`);\n     } catch (availabilityError) {\n       console.error(`❌ [createBooking] Failed to update local availability (Client SDK) for property ${bookingData.propertyId} after creating booking ${bookingId}:`, availabilityError);\n       // Decide if this should block the entire process or just log a warning\n       // Re-throwing the error might be safer if availability is critical\n       throw availabilityError; // Re-throw to indicate the overall process partially failed\n     }\n\n     // --- Synchronize Availability with External Platforms ---\n      console.log(`[createBooking] Starting external platform sync for property ${bookingData.propertyId}, booking ${bookingId}...`);\n      try {\n         const propertyDetails = await getPropertyForSync(bookingData.propertyId);\n         if (propertyDetails) {\n             if (propertyDetails.airbnbListingId) {\n                 await updateAirbnbListingAvailability(propertyDetails.airbnbListingId, false, checkInDate, checkOutDate);\n                 console.log(`[createBooking Sync] Initiated Airbnb availability update for listing ${propertyDetails.airbnbListingId}.`);\n             } else {\n                  console.log(`[createBooking Sync] No Airbnb Listing ID found for property ${bookingData.propertyId}. Skipping Airbnb sync.`);\n             }\n             if (propertyDetails.bookingComListingId) {\n                 await updateBookingComListingAvailability(propertyDetails.bookingComListingId, false, checkInDate, checkOutDate);\n                 console.log(`[createBooking Sync] Initiated Booking.com availability update for listing ${propertyDetails.bookingComListingId}.`);\n             } else {\n                  console.log(`[createBooking Sync] No Booking.com Listing ID found for property ${bookingData.propertyId}. Skipping Booking.com sync.`);\n             }\n         } else {\n              console.warn(`[createBooking Sync] Could not retrieve property details for ${bookingData.propertyId} to perform external sync.`);\n         }\n     } catch (syncError) {\n         console.error(`❌ [createBooking Sync] Error synchronizing availability with external platforms for property ${bookingData.propertyId} after creating booking ${bookingId}:`, syncError);\n         // Log this but don't necessarily fail the entire booking creation\n     }\n\n     console.log(`--- [createBooking] Function returning successfully with booking ID: ${bookingId} ---`);\n     return bookingId;\n\n   } catch (error) {\n      // Avoid logging validation errors twice\n      if (!(error instanceof Error && error.message.startsWith('Invalid booking data:'))) {\n          console.error(`❌ [createBooking] Error during booking creation process for Payment Intent [${paymentIntentId}]:`, error);\n      }\n     // Construct a user-friendly error message, hiding internal details unless it's a validation error\n     const errorMessage = error instanceof Error\n         ? (error.message.startsWith('Invalid booking data:') ? error.message : `Failed to create booking (Ref: ${paymentIntentId}). Please contact support.`) // More generic for other errors\n         : `An unexpected error occurred while creating the booking (Ref: ${paymentIntentId}). Please contact support.`;\n\n     throw new Error(errorMessage);\n   }\n }\n\n/**\n * Retrieves a booking document by its ID using the Client SDK.\n */\nexport async function getBookingById(bookingId: string): Promise<Booking | null> {\n    try {\n        const bookingRef = doc(db, 'bookings', bookingId); // Use Client SDK 'db'\n        const docSnap = await getDoc(bookingRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data();\n            // Convert Timestamps if needed for client consumption, or keep as Timestamps\n            const bookingResult = {\n                id: docSnap.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n            } as Booking;\n            return bookingResult;\n        } else {\n            console.warn(`[getBookingById] No booking found with ID: ${bookingId}`);\n            return null;\n        }\n    } catch (error) {\n        console.error(`❌ [getBookingById] Error fetching booking with ID ${bookingId}:`, error);\n        throw new Error(`Failed to fetch booking: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Updates the status of a specific booking document using the Client SDK.\n * Calls updatePropertyAvailability (Client SDK) if status is 'cancelled'.\n */\nexport async function updateBookingStatus(bookingId: string, status: Booking['status']): Promise<void> {\n    try {\n        const bookingRef = doc(db, 'bookings', bookingId); // Use Client SDK 'db'\n        await updateDoc(bookingRef, {\n            status: status,\n            updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n        });\n        console.log(`✅ [updateBookingStatus] Successfully updated booking ${bookingId} to status: ${status}`);\n\n        if (status === 'cancelled') {\n          const booking = await getBookingById(bookingId); // Re-fetch using Client SDK\n          if (booking && booking.checkInDate && booking.checkOutDate) {\n            // Convert Client Timestamps back to Dates\n            const checkIn = (booking.checkInDate as ClientTimestamp).toDate();\n            const checkOut = (booking.checkOutDate as ClientTimestamp).toDate();\n            try {\n                // **** Call function using Client SDK ****\n                await updatePropertyAvailability(booking.propertyId, checkIn, checkOut, true);\n                console.log(`✅ [updateBookingStatus] Successfully updated local availability (Client SDK) for cancelled booking ${bookingId}.`);\n            } catch (availError) {\n                 console.error(`❌ [updateBookingStatus] Failed to update local availability (Client SDK) for cancelled booking ${bookingId}:`, availError);\n            }\n\n             // Trigger external sync\n             try {\n                const propertyDetails = await getPropertyForSync(booking.propertyId);\n                if (propertyDetails) {\n                    if (propertyDetails.airbnbListingId) {\n                        await updateAirbnbListingAvailability(propertyDetails.airbnbListingId, true, checkIn, checkOut);\n                         console.log(`[Sync] Initiated Airbnb date release for ${propertyDetails.airbnbListingId}`);\n                    }\n                     if (propertyDetails.bookingComListingId) {\n                        await updateBookingComListingAvailability(propertyDetails.bookingComListingId, true, checkIn, checkOut);\n                         console.log(`[Sync] Initiated Booking.com date release for ${propertyDetails.bookingComListingId}`);\n                    }\n                } else {\n                    console.warn(`[Sync] Could not find property details for ${booking.propertyId} to sync cancellation.`);\n                }\n             } catch (syncError) {\n                 console.error(`❌ [Sync] Error syncing availability after cancellation for booking ${bookingId}:`, syncError);\n             }\n          } else {\n             console.warn(`[updateBookingStatus] Could not find booking ${bookingId} or its dates to update availability after cancellation.`);\n          }\n        }\n\n    } catch (error) {\n        console.error(`❌ [updateBookingStatus] Error updating status for booking ${bookingId} (Client SDK):`, error);\n        throw new Error(`Failed to update booking status: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Retrieves all bookings associated with a specific property ID using the Client SDK.\n */\nexport async function getBookingsForProperty(propertyId: string): Promise<Booking[]> {\n    const bookings: Booking[] = [];\n    try {\n        const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db'\n        const q = query(bookingsCollection, where('propertyId', '==', propertyId));\n        const querySnapshot = await getDocs(q);\n\n        querySnapshot.forEach((doc) => {\n            const data = doc.data();\n            bookings.push({\n                id: doc.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n            } as Booking);\n        });\n        return bookings;\n    } catch (error) {\n        console.error(`❌ [getBookingsForProperty] Error fetching bookings for property ${propertyId}:`, error);\n        throw new Error(`Failed to fetch bookings for property: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Retrieves all bookings associated with a specific user ID using the Client SDK.\n */\nexport async function getBookingsForUser(userId: string): Promise<Booking[]> {\n     const bookings: Booking[] = [];\n    try {\n        const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db'\n        const q = query(bookingsCollection, where('guestInfo.userId', '==', userId));\n        const querySnapshot = await getDocs(q);\n\n        querySnapshot.forEach((doc) => {\n             const data = doc.data();\n             bookings.push({\n                 id: doc.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n             } as Booking);\n        });\n        return bookings;\n    } catch (error) {\n        console.error(`❌ [getBookingsForUser] Error fetching bookings for user ${userId}:`, error);\n        throw new Error(`Failed to fetch bookings for user: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n\n/**\n * Updates the availability status for a given property and date range in Firestore\n * using the **Firebase Client SDK**.\n *\n * This function relies on Firestore security rules to allow the necessary writes.\n * It should be called from a trusted server environment (e.g., a Next.js server action)\n * that runs under an appropriate authentication context if required by the rules.\n */\nexport async function updatePropertyAvailability(propertyId: string, checkInDate: Date, checkOutDate: Date, available: boolean): Promise<void> {\n  console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function called ---`);\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Args: propertyId=${propertyId}, checkIn=${format(checkInDate, 'yyyy-MM-dd')}, checkOut=${format(checkOutDate, 'yyyy-MM-dd')} (exclusive), available=${available}`);\n\n  if (!db) {\n    console.error(\"❌ [updatePropertyAvailability - CLIENT SDK] Firestore Client SDK (db) is not initialized. Cannot update availability.\");\n    throw new Error(\"Firestore Client SDK is not initialized.\");\n  }\n\n  if (checkOutDate <= checkInDate) {\n    console.warn(`[updatePropertyAvailability] Check-out date (${format(checkOutDate, 'yyyy-MM-dd')}) must be after check-in date (${format(checkInDate, 'yyyy-MM-dd')}). No update performed.`);\n    return;\n  }\n\n  const datesToUpdate = eachDayOfInterval({\n    start: checkInDate,\n    end: subDays(checkOutDate, 1) // Make checkout date exclusive\n  });\n\n  if (datesToUpdate.length === 0) {\n    console.log(\"[updatePropertyAvailability - CLIENT SDK] No dates need updating.\");\n    return;\n  }\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Dates to update (${datesToUpdate.length}): ${datesToUpdate.map(d => format(d, 'yyyy-MM-dd')).join(', ')}`);\n\n  const updatesByMonth: { [month: string]: { [day: number]: boolean } } = {};\n  datesToUpdate.forEach(date => {\n    const monthStr = format(date, 'yyyy-MM');\n    const dayOfMonth = date.getDate();\n    if (!updatesByMonth[monthStr]) {\n      updatesByMonth[monthStr] = {};\n    }\n    updatesByMonth[monthStr][dayOfMonth] = available;\n  });\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Updates grouped by month:`, JSON.stringify(updatesByMonth));\n\n\n  const batch = clientWriteBatch(db); // Use clientWriteBatch with client db\n  const availabilityCollection = collection(db, 'availability'); // Use client db\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Initialized Firestore Client batch.`);\n\n  try {\n    const monthStrings = Object.keys(updatesByMonth);\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Processing months: ${monthStrings.join(', ')}`);\n\n    if (monthStrings.length === 0) {\n      console.log(\"[updatePropertyAvailability - CLIENT SDK] No months to process.\");\n      return;\n    }\n\n    // Fetch existing docs using Client SDK 'in' query\n    const docIdsToFetch = monthStrings.map(monthStr => `${propertyId}_${monthStr}`);\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Fetching existing availability docs for ${monthStrings.length} months...`);\n\n    // Split into batches if necessary (max 30 IDs per 'in' query)\n    const idBatches: string[][] = [];\n    for (let i = 0; i < docIdsToFetch.length; i += 30) {\n      idBatches.push(docIdsToFetch.slice(i, i + 30));\n    }\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Split into ${idBatches.length} query batches due to 'in' operator limit.`);\n\n    const fetchedDocsMap = new Map<string, Availability>();\n    await Promise.all(idBatches.map(async (batchIds, index) => {\n      if (batchIds.length === 0) return;\n      console.log(`[updatePropertyAvailability - CLIENT SDK] Executing query for batch ${index + 1}: ${batchIds.join(', ')}`);\n      const q = query(availabilityCollection, where(documentId(), 'in', batchIds));\n      const querySnapshot = await getDocs(q);\n      querySnapshot.forEach(docSnap => {\n        if (docSnap.exists()) {\n          fetchedDocsMap.set(docSnap.id, { id: docSnap.id, ...docSnap.data() } as Availability);\n        }\n      });\n    }));\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Fetched ${fetchedDocsMap.size} existing doc snapshots.`);\n\n    monthStrings.forEach(monthStr => {\n      const availabilityDocId = `${propertyId}_${monthStr}`;\n      console.log(`[updatePropertyAvailability Batch Prep] Processing month ${monthStr} (Doc ID: ${availabilityDocId}). Updates needed for days: ${Object.keys(updatesByMonth[monthStr]).join(', ')}`);\n      const availabilityDocRef = doc(availabilityCollection, availabilityDocId); // Use client db\n      const updatesForDay = updatesByMonth[monthStr];\n\n      const updatePayload: { [key: string]: boolean | SerializableTimestamp } = {}; // Use SerializableTimestamp for serverTimestamp\n      for (const day in updatesForDay) {\n        updatePayload[`available.${String(day)}`] = updatesForDay[day];\n      }\n      updatePayload.updatedAt = clientServerTimestamp(); // Use Client serverTimestamp\n      console.log(`[updatePropertyAvailability Batch Prep] Prepared update payload for ${availabilityDocId}:`, JSON.stringify({ ...updatePayload, updatedAt: 'ServerTimestamp' }));\n\n\n      const existingDoc = fetchedDocsMap.get(availabilityDocId);\n\n      if (existingDoc) {\n        console.log(`[updatePropertyAvailability Batch Prep] Doc ${availabilityDocId} exists. Adding UPDATE operation to client batch.`);\n        batch.update(availabilityDocRef, updatePayload);\n      } else {\n        console.log(`[updatePropertyAvailability Batch Prep] Doc ${availabilityDocId} DOES NOT exist. Creating initial data for month ${monthStr}.`);\n        const [year, month] = monthStr.split('-').map(Number);\n        const daysInMonth = new Date(year, month, 0).getDate();\n        const initialAvailableMap: { [day: number]: boolean } = {};\n        for (let day = 1; day <= daysInMonth; day++) {\n          initialAvailableMap[day] = updatesForDay[day] !== undefined ? updatesForDay[day] : true; // Apply update if exists, else default to true\n        }\n        console.log(`[updatePropertyAvailability Batch Prep] Calculated initial availability map for ${daysInMonth} days in ${monthStr}.`);\n\n        const newDocData: Partial<Availability> = {\n          propertyId: propertyId,\n          month: monthStr,\n          available: initialAvailableMap,\n          updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n        };\n        console.log(`[updatePropertyAvailability Batch Prep] New doc data for ${availabilityDocId}:`, JSON.stringify({ ...newDocData, updatedAt: 'ServerTimestamp' }));\n        console.log(`[updatePropertyAvailability Batch Prep] Adding SET operation (merge: true) to client batch for ${availabilityDocId}.`);\n        batch.set(availabilityDocRef, newDocData, { merge: true }); // Use merge: true to avoid overwriting existing fields if any\n      }\n    });\n\n    // Commit the Client SDK batch write\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Preparing to commit client batch for property ${propertyId}, months: ${monthStrings.join(', ')}...`);\n    await batch.commit();\n    console.log(`✅ [updatePropertyAvailability - CLIENT SDK] Successfully committed batch updates for local availability for property ${propertyId}.`);\n    console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function finished successfully ---`);\n\n\n  } catch (error) {\n    // This error might be due to Firestore security rules denying the write.\n    console.error(`❌ Error during Client SDK batch update/creation for property availability ${propertyId}:`, error);\n    console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function throwing error ---`);\n    throw new Error(`Failed to update local property availability using Client SDK: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n\n/**\n * Fetches all unavailable dates for a given property within a reasonable future range\n * using the **Client SDK**.\n */\nexport async function getUnavailableDatesForProperty(propertyId: string, monthsToFetch: number = 12): Promise<Date[]> {\n  const unavailableDates: Date[] = [];\n  console.log(`--- [getUnavailableDatesForProperty] Function called ---`);\n  console.log(`[getUnavailableDatesForProperty] Fetching for property ${propertyId} for the next ${monthsToFetch} months.`);\n\n  if (!db) {\n      console.error(\"❌ [getUnavailableDatesForProperty] Firestore Client SDK (db) is not initialized. Cannot fetch availability.\");\n      return []; // Return empty array if DB not ready\n  }\n\n  const availabilityCollection = collection(db, 'availability'); // Use Client SDK 'db'\n  const today = new Date();\n  // Use UTC for consistency when dealing with dates across potential timezones\n  const currentMonthStart = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));\n  console.log(`[getUnavailableDatesForProperty] Today (UTC): ${today.toISOString()}, Current Month Start (UTC): ${currentMonthStart.toISOString()}`);\n\n\n  try {\n    const monthDocIds: string[] = [];\n    for (let i = 0; i < monthsToFetch; i++) {\n      // Calculate target month correctly in UTC\n      const targetMonth = new Date(Date.UTC(currentMonthStart.getUTCFullYear(), currentMonthStart.getUTCMonth() + i, 1));\n      const monthStr = format(targetMonth, 'yyyy-MM');\n      monthDocIds.push(`${propertyId}_${monthStr}`);\n    }\n    console.log(`[getUnavailableDatesForProperty] Querying for document IDs: ${monthDocIds.join(', ')}`);\n\n\n    const queryBatches: string[][] = [];\n    for (let i = 0; i < monthDocIds.length; i += 30) { // Firestore 'in' query supports up to 30 elements\n        queryBatches.push(monthDocIds.slice(i, i + 30));\n    }\n    console.log(`[getUnavailableDatesForProperty] Split into ${queryBatches.length} query batches due to 'in' operator limit.`);\n\n     if (monthDocIds.length === 0) {\n        console.log(\"[getUnavailableDatesForProperty] No month document IDs to query. Returning empty array.\");\n        return [];\n    }\n\n    // Execute queries using Client SDK\n    const allQuerySnapshots = await Promise.all(\n      queryBatches.map(async (batchIds, index) => {\n          console.log(`[getUnavailableDatesForProperty] Executing query for batch ${index + 1}: ${batchIds.join(', ')}`);\n          const q = query(availabilityCollection, where(documentId(), 'in', batchIds)); // Use documentId() for client query\n          return getDocs(q);\n      })\n    );\n    console.log(`[getUnavailableDatesForProperty] Fetched results from ${allQuerySnapshots.length} batches.`);\n\n\n    allQuerySnapshots.forEach((querySnapshot, batchIndex) => {\n         console.log(`[getUnavailableDatesForProperty] Processing batch ${batchIndex + 1}: Found ${querySnapshot.docs.length} documents.`);\n         querySnapshot.forEach((doc) => {\n            const data = doc.data() as Partial<Availability>;\n            const docId = doc.id;\n            console.log(`[getUnavailableDatesForProperty] Processing doc: ${docId}`);\n            const monthStrFromId = docId.split('_')[1];\n            const monthStrFromData = data.month;\n            // Prefer month from data if available, fallback to parsing from ID\n            const monthStr = monthStrFromData || monthStrFromId;\n\n             if (!monthStr || !/^\\d{4}-\\d{2}$/.test(monthStr)) {\n                 console.warn(`[getUnavailableDatesForProperty] Could not determine valid month string for doc ${docId}. Skipping.`);\n                 return;\n             }\n\n            if (data.available && typeof data.available === 'object') {\n                const [year, monthIndex] = monthStr.split('-').map(num => parseInt(num, 10));\n                const month = monthIndex - 1; // JS months are 0-indexed\n                 console.log(`[getUnavailableDatesForProperty] Doc ${docId} (Month: ${monthStr}): Processing availability map...`);\n\n                for (const dayStr in data.available) {\n                    const day = parseInt(dayStr, 10);\n                    if (!isNaN(day) && data.available[day] === false) {\n                        try {\n                            if (year > 0 && month >= 0 && month < 12 && day > 0 && day <= 31) {\n                                const date = new Date(Date.UTC(year, month, day)); // Work in UTC\n                                 if (date.getUTCFullYear() === year && date.getUTCMonth() === month && date.getUTCDate() === day) {\n                                    const todayUtcStart = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));\n                                    if (date >= todayUtcStart) {\n                                        console.log(`   - Found unavailable date: ${format(date, 'yyyy-MM-dd')}`);\n                                        unavailableDates.push(date);\n                                    } else {\n                                        console.log(`   - Found past unavailable date: ${format(date, 'yyyy-MM-dd')}. Ignoring.`);\n                                    }\n                                 } else {\n                                     console.warn(`[getUnavailableDatesForProperty] Invalid date created for ${year}-${monthStr}-${dayStr} in doc ${docId}. Skipping.`);\n                                 }\n                            } else {\n                                 console.warn(`[getUnavailableDatesForProperty] Invalid year/month/day components found in doc ${docId}: year=${year}, month=${monthIndex}, day=${dayStr}. Skipping.`);\n                            }\n                        } catch (dateError) {\n                             console.warn(`[getUnavailableDatesForProperty] Error creating date for ${year}-${monthStr}-${dayStr} in doc ${docId}:`, dateError, `. Skipping.`);\n                        }\n                    }\n                }\n            } else {\n                 console.warn(`[getUnavailableDatesForProperty] Document ${docId} has missing or invalid 'available' data. Skipping.`);\n            }\n        });\n    });\n\n    unavailableDates.sort((a, b) => a.getTime() - b.getTime());\n    console.log(`[getUnavailableDatesForProperty] Total unavailable dates found for property ${propertyId}: ${unavailableDates.length}`);\n    console.log(`[getUnavailableDatesForProperty] Returning sorted unavailable dates: ${unavailableDates.map(d => format(d, 'yyyy-MM-dd')).join(', ')}`);\n    console.log(`--- [getUnavailableDatesForProperty] Function finished successfully ---`);\n    return unavailableDates;\n\n  } catch (error) {\n    console.error(`❌ Error fetching unavailable dates for property ${propertyId}:`, error);\n    console.log(`--- [getUnavailableDatesForProperty] Function finished with error ---`);\n    return []; // Return empty array on error\n  }\n}"],"names":[],"mappings":"AAAA,iCAAiC;;;;;;;;;;;;IAwHX;IAsIA;IAmCA;IAuDA;IAgCA;IAsCA;IAwIA","debugId":null}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/couponService.ts"],"sourcesContent":["\n// src/services/couponService.ts\n'use server';\n\nimport { collection, doc, getDoc, Timestamp, where, query, getDocs, limit } from 'firebase/firestore';\nimport { db } from '@/lib/firebase'; // Client SDK Firestore instance\nimport type { Coupon, SerializableTimestamp } from '@/types';\nimport { parseISO, isWithinInterval, areIntervalsOverlapping } from 'date-fns'; // Changed 'overlaps' to 'areIntervalsOverlapping'\n\n// Helper function to convert SerializableTimestamp to Date or null\nconst toDate = (timestamp: SerializableTimestamp | undefined | null): Date | null => {\n  if (!timestamp) return null;\n  if (timestamp instanceof Date) return timestamp;\n  if (timestamp instanceof Timestamp) return timestamp.toDate();\n  if (typeof timestamp === 'string') {\n    try {\n      return parseISO(timestamp);\n    } catch {\n      return null;\n    }\n  }\n  if (typeof timestamp === 'number') {\n    // Assuming number is milliseconds since epoch\n    return new Date(timestamp);\n  }\n  return null;\n};\n\n/**\n * Validates a coupon code against the Firestore 'coupons' collection.\n * Checks existence, activity status, expiry, booking validity timeframe, and exclusion periods.\n *\n * @param couponCode - The coupon code string entered by the user.\n * @param bookingCheckInDate - The check-in date of the booking.\n * @param bookingCheckOutDate - The check-out date of the booking.\n * @returns A promise resolving to an object with discount percentage or an error message.\n */\nexport async function validateAndApplyCoupon(\n  couponCode: string,\n  bookingCheckInDate: Date | null,\n  bookingCheckOutDate: Date | null\n): Promise<{ discountPercentage?: number; error?: string }> {\n  if (!couponCode) {\n    return { error: 'Coupon code cannot be empty.' };\n  }\n  if (!bookingCheckInDate || !bookingCheckOutDate || bookingCheckOutDate <= bookingCheckInDate) {\n      return { error: 'Valid booking dates are required to apply a coupon.' };\n  }\n\n  const couponCodeUpper = couponCode.toUpperCase(); // Normalize code\n\n  try {\n    const couponsCollection = collection(db, 'coupons');\n    const q = query(couponsCollection, where('code', '==', couponCodeUpper), limit(1));\n    const querySnapshot = await getDocs(q);\n\n    if (querySnapshot.empty) {\n      console.warn(`[Coupon Service] Coupon code \"${couponCodeUpper}\" not found.`);\n      return { error: 'Invalid coupon code.' };\n    }\n\n    const couponDoc = querySnapshot.docs[0];\n    // Cast data to include new fields, ensuring they can be null/undefined\n    const couponData = couponDoc.data() as Omit<Coupon, 'id' | 'createdAt' | 'updatedAt' | 'validUntil' | 'bookingValidFrom' | 'bookingValidUntil' | 'exclusionPeriods'> & {\n        createdAt: any;\n        updatedAt?: any;\n        validUntil: any;\n        bookingValidFrom?: any | null;\n        bookingValidUntil?: any | null;\n        exclusionPeriods?: Array<{ start: any; end: any }> | null;\n    };\n\n\n    // --- Basic Validations ---\n    if (!couponData.isActive) {\n      console.warn(`[Coupon Service] Coupon code \"${couponCodeUpper}\" is not active.`);\n      return { error: 'Coupon code is no longer active.' };\n    }\n\n    const couponExpiryDate = toDate(couponData.validUntil);\n    const now = new Date(); // Compare with current date, not just timestamp\n    // Make comparison based on the start of the day for coupon expiry\n    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    if (couponExpiryDate && couponExpiryDate < todayStart) {\n      console.warn(`[Coupon Service] Coupon code \"${couponCodeUpper}\" has expired on ${couponExpiryDate.toISOString().split('T')[0]}.`);\n      return { error: 'Coupon code has expired.' };\n    }\n\n\n    if (typeof couponData.discount !== 'number' || couponData.discount <= 0 || couponData.discount > 100) {\n      console.error(`[Coupon Service] Invalid discount percentage (${couponData.discount}) for coupon \"${couponCodeUpper}\".`);\n      return { error: 'Invalid coupon configuration.' };\n    }\n\n    // --- Booking Timeframe Validations ---\n    const bookingValidFrom = toDate(couponData.bookingValidFrom);\n    const bookingValidUntil = toDate(couponData.bookingValidUntil);\n\n    // Check if booking starts before the valid period\n    if (bookingValidFrom && bookingCheckInDate < bookingValidFrom) {\n        console.warn(`[Coupon Service] Booking check-in (${bookingCheckInDate.toISOString().split('T')[0]}) is before coupon booking validity start (${bookingValidFrom.toISOString().split('T')[0]}) for \"${couponCodeUpper}\".`);\n        return { error: 'Coupon not valid for selected check-in date.' };\n    }\n\n    // Check if booking ends after the valid period\n    // For bookingValidUntil, we should check if the *check-in* date is after the validity end date\n    // OR if the check-out date is strictly after the validity end date.\n    if (bookingValidUntil) {\n         // Set validity end to the end of the day for comparison\n         const validityEndDate = new Date(bookingValidUntil.getFullYear(), bookingValidUntil.getMonth(), bookingValidUntil.getDate(), 23, 59, 59, 999);\n         if (bookingCheckInDate > validityEndDate) {\n             console.warn(`[Coupon Service] Booking check-in (${bookingCheckInDate.toISOString().split('T')[0]}) is after coupon booking validity end (${bookingValidUntil.toISOString().split('T')[0]}) for \"${couponCodeUpper}\".`);\n             return { error: 'Coupon not valid for selected check-in date.' };\n         }\n         // Note: Check-out date is typically exclusive. A booking ending on the validity date should be allowed.\n         // However, if the policy is strict, you might compare bookingCheckOutDate > validityEndDate + 1 day or similar.\n         // Sticking to check-in date for simplicity based on typical coupon logic.\n    }\n\n\n    // --- Exclusion Period Validations ---\n    if (couponData.exclusionPeriods && Array.isArray(couponData.exclusionPeriods)) {\n        // The booking interval includes the check-in day but excludes the check-out day for night calculations.\n        // For overlap checking, we should consider the full range of occupied days.\n        const bookingInterval = { start: bookingCheckInDate, end: new Date(bookingCheckOutDate.getTime() - 1) }; // Adjust end date to be inclusive\n\n        for (const period of couponData.exclusionPeriods) {\n            const exclusionStart = toDate(period.start);\n            const exclusionEnd = toDate(period.end);\n\n            if (exclusionStart && exclusionEnd) {\n                // Ensure exclusion end is inclusive for overlap check\n                const exclusionInterval = { start: exclusionStart, end: new Date(exclusionEnd.getFullYear(), exclusionEnd.getMonth(), exclusionEnd.getDate(), 23, 59, 59, 999)};\n                // Check if the booking interval overlaps with any exclusion interval\n                if (areIntervalsOverlapping(bookingInterval, exclusionInterval, { inclusive: true })) { // Use areIntervalsOverlapping\n                     console.warn(`[Coupon Service] Booking dates (${bookingCheckInDate.toISOString().split('T')[0]} - ${bookingCheckOutDate.toISOString().split('T')[0]}) overlap with exclusion period (${exclusionStart.toISOString().split('T')[0]} - ${exclusionEnd.toISOString().split('T')[0]}) for \"${couponCodeUpper}\".`);\n                     return { error: 'Coupon not valid for the selected dates due to an exclusion period.' };\n                }\n            } else {\n                 console.warn(`[Coupon Service] Invalid exclusion period found for coupon \"${couponCodeUpper}\":`, period);\n            }\n        }\n    }\n\n\n    // TODO: Add validation for usage limits if implemented (maxUses, currentUses)\n\n    console.log(`[Coupon Service] Coupon code \"${couponCodeUpper}\" validated successfully for the booking dates. Discount: ${couponData.discount}%`);\n    return { discountPercentage: couponData.discount };\n\n  } catch (error) {\n    console.error(`❌ [Coupon Service] Error validating coupon code \"${couponCodeUpper}\":`, error);\n    return { error: 'Could not validate coupon code. Please try again.' }; // Generic error for the user\n  }\n}\n"],"names":[],"mappings":"AACA,gCAAgC;;;;;;IAoCV","debugId":null}},
    {"offset": {"line": 539, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/booking-form.tsx"],"sourcesContent":["\n\"use client\"; // Required for form handling, state, and Stripe JS\n\nimport * as React from 'react';\nimport { useState, useEffect, useCallback } from 'react';\nimport { format, differenceInDays, addDays, parseISO } from 'date-fns';\nimport type { DateRange } from 'react-day-picker'; // Ensure DateRange is imported\nimport { Calendar as CalendarIcon, Users, Minus, Plus, Loader2, TestTubeDiagonal, TicketPercent, X } from 'lucide-react'; // Added Loader2, TestTubeDiagonal, TicketPercent, X\n\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Calendar } from '@/components/ui/calendar';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport { Label } from '@/components/ui/label';\nimport { Input } from '@/components/ui/input'; // Keep input for coupon\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { Property, Booking, Coupon } from '@/types'; // Import Booking type for status, Coupon type\nimport { Separator } from './ui/separator';\nimport { createCheckoutSession } from '@/app/actions/create-checkout-session'; // Import server action\nimport { getUnavailableDatesForProperty, createBooking, type CreateBookingData } from '@/services/bookingService'; // Import booking services\nimport { validateAndApplyCoupon } from '@/services/couponService'; // Import coupon service\n\ninterface BookingFormProps {\n  property: Property;\n}\n\n\n// Load Stripe outside component to avoid recreating on every render\n// Ensure your Stripe publishable key is in an environment variable\nconst stripePromise = import('@stripe/stripe-js').then(m => m.loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || ''));\n\nif (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {\n  console.warn('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY is not set. Stripe functionality will be limited.');\n}\n\n\nexport function BookingForm({ property }: BookingFormProps) {\n  const [date, setDate] = useState<DateRange | undefined>(undefined);\n  const [numberOfGuests, setNumberOfGuests] = useState(1); // Start with 1 guest\n  const [totalPrice, setTotalPrice] = useState<number | null>(null);\n  const [subtotal, setSubtotal] = useState<number | null>(null); // Store pre-discount subtotal\n  const [numberOfNights, setNumberOfNights] = useState(0);\n  const [extraGuestCost, setExtraGuestCost] = useState(0);\n  const [isSubmitting, setIsSubmitting] = useState(false); // Loading state for Stripe\n  const [isTesting, setIsTesting] = useState(false); // Loading state for Test Booking\n  const [unavailableDates, setUnavailableDates] = useState<Date[]>([]); // State for unavailable dates\n  const [isLoadingAvailability, setIsLoadingAvailability] = useState(true);\n  const [couponCode, setCouponCode] = useState('');\n  const [appliedCoupon, setAppliedCoupon] = useState<{ code: string; discountPercentage: number } | null>(null);\n  const [couponError, setCouponError] = useState<string | null>(null);\n  const [isApplyingCoupon, setIsApplyingCoupon] = useState(false);\n  const { toast } = useToast();\n\n\n  // Fetch unavailable dates when the component mounts or property changes\n  useEffect(() => {\n    async function fetchAvailability() {\n      setIsLoadingAvailability(true);\n      try {\n        const unavailable = await getUnavailableDatesForProperty(property.id);\n        setUnavailableDates(unavailable);\n      } catch (error) {\n        console.error(`❌ [BookingForm fetchAvailability] Error fetching property availability for ${property.id}:`, error);\n        toast({\n          title: \"Error Loading Availability\",\n          description: \"Could not load property availability. Please try refreshing the page.\",\n          variant: \"destructive\",\n        });\n        setUnavailableDates([]);\n      } finally {\n        setIsLoadingAvailability(false);\n      }\n    }\n\n    fetchAvailability();\n  }, [property.id, toast]); // Dependency array includes property.id and toast\n\n  // Calculate price based on dates, guests, and applied coupon\n  const calculatePrice = useCallback(() => {\n    if (date?.from && date?.to && date.to > date.from) {\n      const nights = differenceInDays(date.to, date.from);\n      setNumberOfNights(nights);\n\n      // Calculate extra guest cost\n      const extraGuests = Math.max(0, numberOfGuests - property.baseOccupancy);\n      const calculatedExtraGuestCost = extraGuests * property.extraGuestFee * nights;\n      setExtraGuestCost(calculatedExtraGuestCost);\n\n      // Calculate base accommodation cost\n      const baseAccommodationCost = nights * property.pricePerNight;\n      const accommodationTotal = baseAccommodationCost + calculatedExtraGuestCost;\n\n      // Calculate subtotal (before discount)\n      const currentSubtotal = accommodationTotal + property.cleaningFee;\n      setSubtotal(currentSubtotal);\n\n      // Apply discount if a coupon is applied\n      let finalPrice = currentSubtotal;\n      let discountAmount = 0;\n      if (appliedCoupon) {\n        discountAmount = currentSubtotal * (appliedCoupon.discountPercentage / 100);\n        finalPrice = currentSubtotal - discountAmount;\n      }\n      setTotalPrice(finalPrice);\n\n    } else {\n      setNumberOfNights(0);\n      setExtraGuestCost(0);\n      setSubtotal(null);\n      setTotalPrice(null);\n    }\n  }, [date, numberOfGuests, property, appliedCoupon]); // Dependencies\n\n\n  // Recalculate price whenever relevant state changes\n  useEffect(() => {\n    calculatePrice();\n  }, [calculatePrice]);\n\n\n  const handleGuestChange = (change: number) => {\n    setNumberOfGuests((prev) => {\n      const newCount = prev + change;\n      // Enforce limits: 1 to maxGuests\n      return Math.max(1, Math.min(newCount, property.maxGuests));\n    });\n  };\n\n   // Function to check if the selected date range is valid\n   const isDateRangeValid = (): boolean => {\n     if (!date?.from || !date?.to) {\n       return false;\n     }\n     return date.to > date.from;\n   };\n\n   // --- Handle Coupon Application ---\n   const handleApplyCoupon = async () => {\n     if (!couponCode.trim()) {\n       setCouponError('Please enter a coupon code.');\n       return;\n     }\n     if (!isDateRangeValid()) {\n       setCouponError('Please select valid booking dates first.');\n       return;\n     }\n\n     setIsApplyingCoupon(true);\n     setCouponError(null);\n     setAppliedCoupon(null); // Reset previous coupon on new attempt\n\n     try {\n        // Pass the booking dates to the validation function\n       const result = await validateAndApplyCoupon(\n           couponCode.trim(),\n           date?.from ?? null, // Pass Date objects\n           date?.to ?? null\n        );\n\n       if (result.error) {\n         setCouponError(result.error);\n         setAppliedCoupon(null);\n       } else if (result.discountPercentage) {\n         setAppliedCoupon({ code: couponCode.trim().toUpperCase(), discountPercentage: result.discountPercentage });\n         toast({\n           title: \"Coupon Applied!\",\n           description: `Successfully applied ${result.discountPercentage}% discount.`,\n         });\n       }\n     } catch (error) {\n       console.error('❌ [BookingForm handleApplyCoupon] Error:', error);\n       setCouponError('Could not apply coupon. Please try again.');\n       setAppliedCoupon(null);\n     } finally {\n       setIsApplyingCoupon(false);\n     }\n   };\n\n   // --- Handle Coupon Removal ---\n   const handleRemoveCoupon = () => {\n     setAppliedCoupon(null);\n     setCouponCode(''); // Optionally clear the input field\n     setCouponError(null);\n     toast({\n       title: \"Coupon Removed\",\n       description: \"The discount has been removed.\",\n       variant: \"default\", // Use default variant or another suitable one\n     });\n     // Price recalculation will happen automatically due to useEffect dependency on appliedCoupon\n   };\n\n\n  // --- Handle Stripe Checkout Submission ---\n  const handleStripeSubmit = async (event: React.FormEvent) => {\n    event.preventDefault();\n    setIsSubmitting(true);\n\n    if (!isDateRangeValid() || !totalPrice) {\n       toast({\n        title: \"Error\",\n        description: \"Please select valid check-in/check-out dates.\",\n        variant: \"destructive\",\n      });\n       setIsSubmitting(false);\n      return;\n    }\n\n    if (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {\n       toast({\n        title: \"Configuration Error\",\n        description: \"Stripe is not configured correctly. Cannot proceed with booking.\",\n        variant: \"destructive\",\n      });\n       setIsSubmitting(false);\n       return;\n    }\n\n\n    try {\n      // 1. Call server action to create checkout session\n      const checkoutInput = {\n        property: property, // Pass the whole property or necessary details\n        checkInDate: date.from!.toISOString(),\n        checkOutDate: date.to!.toISOString(),\n        numberOfGuests: numberOfGuests,\n        totalPrice: totalPrice, // Pass the FINAL price after discount\n        numberOfNights: numberOfNights,\n        // Pass coupon info in metadata\n        appliedCouponCode: appliedCoupon?.code,\n        discountPercentage: appliedCoupon?.discountPercentage,\n      };\n      const result = await createCheckoutSession(checkoutInput);\n\n\n       if (result.error || !result.sessionId) {\n        throw new Error(result.error || 'Failed to get session ID.');\n      }\n\n      const { sessionId } = result;\n\n\n      // 2. Redirect to Stripe Checkout\n      const stripe = await stripePromise;\n      if (!stripe) {\n         throw new Error('Stripe.js has not loaded yet.');\n      }\n\n      const { error } = await stripe.redirectToCheckout({ sessionId });\n\n      if (error) {\n        console.error('❌ [BookingForm handleSubmit] Stripe redirect error:', error);\n        toast({\n          title: \"Error Redirecting\",\n          description: error.message || \"Could not redirect to Stripe.\",\n          variant: \"destructive\",\n        });\n         setIsSubmitting(false);\n      }\n      // No need to setIsSubmitting(false) here, as redirect should happen\n    } catch (error) {\n      console.error('❌ [BookingForm handleSubmit] Booking submission error:', error);\n      toast({\n        title: \"Booking Error\",\n        description: error instanceof Error ? error.message : \"An unexpected error occurred during booking.\",\n        variant: \"destructive\",\n      });\n       setIsSubmitting(false);\n    }\n  };\n\n   // --- Handle Test Booking Creation ---\n   const handleTestBookingClick = async () => {\n     setIsTesting(true);\n\n     if (!isDateRangeValid() || !totalPrice || subtotal === null) { // Check subtotal too\n       toast({\n         title: \"Test Booking Error\",\n         description: \"Please select valid dates and ensure price is calculated before creating a test booking.\",\n         variant: \"destructive\",\n       });\n       setIsTesting(false);\n       return;\n     }\n\n     // Construct mock data using form state, including new pricing fields\n     const extraGuests = Math.max(0, numberOfGuests - property.baseOccupancy);\n     const accommodationTotal = (property.pricePerNight * numberOfNights) + extraGuestCost;\n     const calculatedSubtotal = accommodationTotal + property.cleaningFee; // Recalculate subtotal for safety\n     const discountAmount = appliedCoupon ? calculatedSubtotal * (appliedCoupon.discountPercentage / 100) : 0;\n     const finalTotal = calculatedSubtotal - discountAmount; // Final price after potential discount\n\n     const mockBookingData: CreateBookingData = {\n       propertyId: property.id,\n       guestInfo: {\n         firstName: \"Dev\",\n         lastName: \"Tester\",\n         email: `dev.tester.${Date.now()}@example.com`, // Unique email\n         userId: \"dev-user-123\",\n         phone: \"+15551112233\", // Example phone\n       },\n       checkInDate: date.from!.toISOString(),\n       checkOutDate: date.to!.toISOString(),\n       numberOfGuests: numberOfGuests,\n       pricing: { // Ensure this matches the structure expected by createBooking\n         baseRate: property.pricePerNight,\n         numberOfNights: numberOfNights,\n         cleaningFee: property.cleaningFee,\n         extraGuestFee: property.extraGuestFee,\n         numberOfExtraGuests: extraGuests,\n         accommodationTotal: accommodationTotal,\n         subtotal: calculatedSubtotal, // Store the subtotal before discount\n         taxes: 0, // Assuming 0 tax for test\n         discountAmount: discountAmount, // Store the discount amount\n         total: finalTotal, // Final calculated total\n       },\n       appliedCouponCode: appliedCoupon?.code, // Include applied coupon code\n       paymentInput: {\n         stripePaymentIntentId: `mock_pi_${Date.now()}`, // Unique mock ID\n         amount: finalTotal, // Use the final total\n         status: \"succeeded\", // Simulate success\n       },\n       status: 'confirmed' as Booking['status'], // Directly set status\n       source: 'test-button',\n       notes: `Test booking for ${numberOfGuests} guests.${appliedCoupon ? ` Coupon: ${appliedCoupon.code}` : ''}`,\n     };\n\n     try {\n       const bookingId = await createBooking(mockBookingData);\n\n       if (bookingId) {\n         toast({\n           title: \"Test Booking Successful\",\n           description: `Test booking created in Firestore with ID: ${bookingId}`,\n         });\n         // Refresh availability after test booking\n         const unavailable = await getUnavailableDatesForProperty(property.id);\n         setUnavailableDates(unavailable);\n         setDate(undefined); // Reset date after successful test booking\n         setAppliedCoupon(null); // Reset coupon\n         setCouponCode('');\n       } else {\n         toast({\n           title: \"Test Booking Possibly Failed\",\n           description: \"Booking creation completed but didn't return a valid ID.\",\n           variant: \"destructive\",\n         });\n       }\n     } catch (error) {\n       console.error(\"[TestBookingButton] Error creating test booking:\", error);\n       toast({\n         title: \"Test Booking Failed\",\n         description: error instanceof Error ? error.message : \"An unknown error occurred.\",\n         variant: \"destructive\",\n       });\n     } finally {\n       setIsTesting(false);\n     }\n   };\n\n\n  const isButtonDisabled = !isDateRangeValid() || totalPrice === null || isSubmitting || isTesting || isLoadingAvailability;\n\n  return (\n    <form onSubmit={handleStripeSubmit} className=\"space-y-6\">\n      {/* Date Range Picker */}\n      <div className={cn('grid gap-2')}>\n         <Label htmlFor=\"date\">Check-in / Check-out Dates</Label>\n         <Popover>\n          <PopoverTrigger asChild>\n            <Button\n              id=\"date\"\n              variant={'outline'}\n              className={cn(\n                'w-full justify-start text-left font-normal',\n                !date && 'text-muted-foreground'\n              )}\n              disabled={isSubmitting || isTesting || isLoadingAvailability} // Disable while submitting or loading availability\n            >\n              <CalendarIcon className=\"mr-2 h-4 w-4\" />\n              {isLoadingAvailability ? (\n                <span>Loading availability...</span>\n              ) : date?.from ? (\n                date.to ? (\n                  <>\n                    {format(date.from, 'LLL dd, y')} -{' '}\n                    {format(date.to, 'LLL dd, y')}\n                  </>\n                ) : (\n                  format(date.from, 'LLL dd, y')\n                )\n              ) : (\n                <span>Pick a date range</span>\n              )}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-auto p-0\" align=\"start\">\n             {isLoadingAvailability ? (\n                <div className=\"p-4 text-center text-muted-foreground\">Loading...</div>\n             ) : (\n                 <Calendar\n                  initialFocus\n                  mode=\"range\"\n                  defaultMonth={date?.from || new Date()} // Use current month if no date selected\n                  selected={date}\n                  onSelect={setDate}\n                  numberOfMonths={1} // Show 1 month for simplicity in card\n                  disabled={[ // Disable past dates and fetched unavailable dates\n                      { before: new Date(new Date().setHours(0, 0, 0, 0)) }, // Disable dates before today accurately\n                      ...unavailableDates // Spread the fetched unavailable dates\n                    ]}\n                 />\n             )}\n          </PopoverContent>\n        </Popover>\n      </div>\n\n      {/* Guest Selector */}\n       <div>\n        <Label htmlFor=\"guests\">Number of Guests</Label>\n        <div className=\"flex items-center justify-between rounded-md border p-2 mt-1\">\n           <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n              className=\"h-7 w-7\"\n              onClick={() => handleGuestChange(-1)}\n              disabled={numberOfGuests <= 1 || isSubmitting || isTesting} // Disable while submitting/testing\n              aria-label=\"Decrease guests\"\n            >\n              <Minus className=\"h-4 w-4\" />\n            </Button>\n            <span className=\"mx-4 font-medium w-8 text-center\" id=\"guests\">\n             {numberOfGuests}\n             </span>\n           <Button\n              type=\"button\"\n              variant=\"outline\"\n              size=\"icon\"\n               className=\"h-7 w-7\"\n              onClick={() => handleGuestChange(1)}\n              disabled={numberOfGuests >= property.maxGuests || isSubmitting || isTesting} // Disable while submitting/testing\n              aria-label=\"Increase guests\"\n            >\n              <Plus className=\"h-4 w-4\" />\n            </Button>\n        </div>\n         <p className=\"text-xs text-muted-foreground mt-1\">\n            Max {property.maxGuests} guests. Base price for {property.baseOccupancy}.\n            {property.extraGuestFee > 0 && ` $${property.extraGuestFee}/extra guest/night.`}\n          </p>\n      </div>\n\n      <Separator className=\"my-4\" />\n\n      {/* Coupon Code Input */}\n      <div>\n        <Label htmlFor=\"coupon\">Discount Coupon</Label>\n        <div className=\"flex gap-2 mt-1\">\n           <Input\n             id=\"coupon\"\n             placeholder=\"Enter coupon code\"\n             value={couponCode}\n             onChange={(e) => setCouponCode(e.target.value)}\n             className=\"flex-grow\"\n             disabled={isApplyingCoupon || !!appliedCoupon || isSubmitting || isTesting} // Disable if applying, applied, or submitting\n             aria-describedby=\"coupon-feedback\"\n           />\n           {!appliedCoupon ? (\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                onClick={handleApplyCoupon}\n                disabled={isApplyingCoupon || !couponCode.trim() || !isDateRangeValid()} // Also disable if dates not selected\n                aria-label=\"Apply Coupon\"\n              >\n                {isApplyingCoupon ? <Loader2 className=\"h-4 w-4 animate-spin\" /> : <TicketPercent className=\"h-4 w-4\" />}\n                <span className=\"ml-2 hidden sm:inline\">Apply</span>\n              </Button>\n            ) : (\n               <Button\n                 type=\"button\"\n                 variant=\"ghost\" // Use ghost or outline for removal\n                 size=\"icon\"\n                 onClick={handleRemoveCoupon}\n                 aria-label=\"Remove Coupon\"\n                 className='text-destructive hover:bg-destructive/10'\n               >\n                 <X className=\"h-4 w-4\" />\n               </Button>\n            )}\n        </div>\n        <div id=\"coupon-feedback\" className=\"mt-1 h-4 text-xs\">\n           {couponError && <p className=\"text-destructive\">{couponError}</p>}\n           {appliedCoupon && <p className=\"text-green-600\">Applied: {appliedCoupon.code} ({appliedCoupon.discountPercentage}%)</p>}\n        </div>\n      </div>\n\n\n      {/* Price Calculation */}\n       {totalPrice !== null && subtotal !== null && numberOfNights > 0 && (\n        <div className=\"space-y-2 text-sm\">\n          <Separator className=\"my-4\" />\n          {/* Base Accommodation Cost */}\n          <div className=\"flex justify-between\">\n            <span>\n              ${property.pricePerNight} x {numberOfNights} {numberOfNights === 1 ? 'night' : 'nights'} ({property.baseOccupancy} {property.baseOccupancy === 1 ? 'guest' : 'guests'})\n            </span>\n            <span>${(property.pricePerNight * numberOfNights).toFixed(2)}</span>\n          </div>\n           {/* Extra Guest Fees (if applicable) */}\n           {extraGuestCost > 0 && (\n            <div className=\"flex justify-between text-muted-foreground\">\n              <span>\n                Extra guest fee (${property.extraGuestFee}/guest x {Math.max(0, numberOfGuests - property.baseOccupancy)} x {numberOfNights} nights)\n              </span>\n              <span>+${extraGuestCost.toFixed(2)}</span>\n            </div>\n          )}\n          {/* Cleaning Fee */}\n          <div className=\"flex justify-between\">\n            <span>Cleaning fee</span>\n            <span>+${property.cleaningFee.toFixed(2)}</span>\n          </div>\n           <Separator className=\"my-1\" />\n            {/* Subtotal */}\n            <div className=\"flex justify-between font-medium\">\n               <span>Subtotal</span>\n               <span>${subtotal.toFixed(2)}</span>\n            </div>\n\n          {/* Discount (if applicable) */}\n          {appliedCoupon && (\n            <div className=\"flex justify-between text-green-600\">\n              <span>Discount ({appliedCoupon.discountPercentage}% - {appliedCoupon.code})</span>\n              <span>-${(subtotal * (appliedCoupon.discountPercentage / 100)).toFixed(2)}</span>\n            </div>\n          )}\n\n          <Separator className=\"my-2\" />\n           {/* Total Price */}\n          <div className=\"flex justify-between font-bold text-base\">\n            <span>Total</span>\n            <span>${totalPrice.toFixed(2)}</span>\n          </div>\n        </div>\n      )}\n\n      {/* Stripe Payment Button */}\n      <Button\n        type=\"submit\"\n        className=\"w-full bg-primary hover:bg-primary/90 text-primary-foreground\" // Use primary color\n        disabled={isButtonDisabled}\n        >\n        {isSubmitting ? (\n           <>\n             <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n             Processing...\n           </>\n         ) : isLoadingAvailability ? (\n             'Loading Availability...'\n         ) : (\n           'Proceed to Payment'\n         )}\n      </Button>\n      <p className=\"text-xs text-center text-muted-foreground\">\n         You will be redirected to Stripe to complete your payment.\n      </p>\n\n      {/* Test Booking Button (Development Only) */}\n      {process.env.NODE_ENV === 'development' && (\n        <>\n         <Separator className=\"my-4 border-dashed\" />\n          <Button\n            type=\"button\" // Important: Change type to 'button' to prevent form submission\n            variant=\"outline\"\n            className=\"w-full border-destructive text-destructive hover:bg-destructive/10 hover:text-destructive\"\n            onClick={handleTestBookingClick}\n            disabled={isButtonDisabled}\n          >\n            {isTesting ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> Creating Test...\n              </>\n            ) : (\n              <>\n                <TestTubeDiagonal className=\"mr-2 h-4 w-4\" />\n                Create Test Booking (Firestore Only)\n              </>\n            )}\n          </Button>\n           <p className=\"text-xs text-center text-muted-foreground mt-2\">\n             (Development only - Bypasses Stripe)\n          </p>\n        </>\n      )}\n    </form>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}