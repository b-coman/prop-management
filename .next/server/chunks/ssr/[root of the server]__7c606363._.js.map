{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["\n// src/lib/firebase.ts\nimport { initializeApp, getApps, getApp } from 'firebase/app';\nimport { getFirestore } from 'firebase/firestore';\n// Remove dotenv import - let scripts handle their own env loading if needed outside Next.js context\n// import * as dotenv from 'dotenv';\n// import * as path from 'path';\n// import { getAuth } from \"firebase/auth\"; // Add if using Firebase Auth\n// import { getStorage } from \"firebase/storage\"; // Add if using Firebase Storage\n\n// Load environment variables from .env.local at the project root\n// dotenv.config({ path: path.resolve(process.cwd(), '.env.local') }); // No longer needed here, Next.js handles it\n\n// Your web app's Firebase configuration\n// Loaded from environment variables automatically by Next.js\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n  // measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID // Optional: for Analytics\n};\n\n// Remove the checkEnvVars function, as Next.js handles env loading for the app runtime.\n// The script now uses Admin SDK and verifies its own specific requirements.\n/*\nfunction checkEnvVars() {\n    // ... (removed) ...\n}\ncheckEnvVars();\n*/\n\n// Initialize Firebase Client SDK\n// Use getApps() to ensure initialization only happens once within the Next.js app runtime\nlet app;\nif (getApps().length === 0) {\n    // Check if critical client config vars are present before initializing client SDK\n    if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {\n        console.error(\"❌ Client Firebase Config Missing: NEXT_PUBLIC_FIREBASE_API_KEY or NEXT_PUBLIC_FIREBASE_PROJECT_ID is missing in environment variables. Client SDK cannot initialize.\");\n        // Throwing here might break the app build/runtime if env vars aren't set during build phase\n        // Consider logging the error and letting parts of the app fail gracefully if Firebase is needed client-side\n        // throw new Error(\"Missing critical client Firebase configuration. Check environment variables.\");\n    } else {\n        try {\n             app = initializeApp(firebaseConfig);\n             // console.log(\"✅ Firebase Client SDK initialized successfully.\"); // Less verbose logging\n        } catch (initError) {\n            console.error(\"❌ Firebase Client SDK initialization failed:\", initError);\n            // Handle or re-throw the initialization error appropriately\n            // throw initError; // Depending on whether the app can function without Firebase client\n        }\n    }\n} else {\n    app = getApp();\n    // console.log(\"ℹ️ Firebase Client SDK app already initialized.\");\n}\n\n// Initialize Firestore Client SDK only if the app was successfully initialized or retrieved\nlet db;\nif (app) {\n    try {\n        db = getFirestore(app);\n        // console.log(\"✅ Firestore Client SDK initialized successfully.\");\n    } catch (firestoreError) {\n         console.error(\"❌ Firestore Client SDK initialization failed:\", firestoreError);\n         // Handle or re-throw the Firestore initialization error\n    }\n} else {\n     console.error(\"❌ Cannot initialize Firestore Client SDK because Firebase app is not available.\");\n}\n\n// const auth = getAuth(app); // Initialize Auth if needed\n// const storage = getStorage(app); // Initialize Storage if needed\n\n// Export only the client SDK instances needed by the application runtime\nexport { app, db /*, auth, storage */ };\n"],"names":[],"mappings":"AACA,sBAAsB;;;;;AACtB;AAAA;AACA;AAAA;;;AACA,oGAAoG;AACpG,oCAAoC;AACpC,gCAAgC;AAChC,yEAAyE;AACzE,kFAAkF;AAElF,iEAAiE;AACjE,mHAAmH;AAEnH,wCAAwC;AACxC,6DAA6D;AAC7D,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AAEP;AAEA,wFAAwF;AACxF,4EAA4E;AAC5E;;;;;AAKA,GAEA,iCAAiC;AACjC,0FAA0F;AAC1F,IAAI;AACJ,IAAI,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,KAAK,GAAG;IACxB,kFAAkF;IAClF,IAAI,CAAC,eAAe,MAAM,IAAI,CAAC,eAAe,SAAS,EAAE;QACrD,QAAQ,KAAK,CAAC;IACd,4FAA4F;IAC5F,4GAA4G;IAC5G,mGAAmG;IACvG,OAAO;QACH,IAAI;YACC,MAAM,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE;QACpB,0FAA0F;QAC/F,EAAE,OAAO,WAAW;YAChB,QAAQ,KAAK,CAAC,gDAAgD;QAC9D,4DAA4D;QAC5D,wFAAwF;QAC5F;IACJ;AACJ,OAAO;IACH,MAAM,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;AACX,kEAAkE;AACtE;AAEA,4FAA4F;AAC5F,IAAI;AACJ,IAAI,KAAK;IACL,IAAI;QACA,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE;IAClB,mEAAmE;IACvE,EAAE,OAAO,gBAAgB;QACpB,QAAQ,KAAK,CAAC,iDAAiD;IAC/D,wDAAwD;IAC7D;AACJ,OAAO;IACF,QAAQ,KAAK,CAAC;AACnB","debugId":null}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/booking-sync.ts"],"sourcesContent":["/**\n * @fileoverview Service functions for synchronizing booking availability with external platforms like Airbnb and Booking.com.\n * IMPORTANT: These functions currently contain placeholder logic and require actual API integration.\n */\n'use server';\n\nimport { doc, getDoc } from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\nimport type { Property } from '@/types'; // Assuming Property type includes external IDs\n\n/**\n * Represents the details of an Airbnb listing relevant for sync.\n */\nexport interface AirbnbListing {\n  listingId: string;\n  isAvailable: boolean;\n  pricePerNight: number;\n}\n\n/**\n * Represents the details of a Booking.com listing relevant for sync.\n */\nexport interface BookingComListing {\n  listingId: string;\n  isAvailable: boolean;\n  pricePerNight: number;\n}\n\n/**\n * Fetches property details including external listing IDs.\n *\n * @param propertyId The ID of the property to fetch.\n * @returns The Property object or null if not found.\n */\nexport async function getPropertyForSync(propertyId: string): Promise<Property | null> {\n    const propertyRef = doc(db, 'properties', propertyId);\n    try {\n        const docSnap = await getDoc(propertyRef);\n        if (docSnap.exists()) {\n            return { id: docSnap.id, ...docSnap.data() } as Property;\n        } else {\n            console.warn(`[getPropertyForSync] Property document not found in Firestore: properties/${propertyId}`);\n            return null;\n        }\n    } catch (error) {\n         console.error(`❌ [getPropertyForSync] Error fetching property ${propertyId}:`, error);\n         return null;\n    }\n}\n\n\n/**\n * Asynchronously retrieves Airbnb listing details.\n * PLACEHOLDER IMPLEMENTATION. Requires actual Airbnb API call.\n *\n * @param listingId The Airbnb listing ID.\n * @returns A promise that resolves to an AirbnbListing object.\n */\nexport async function getAirbnbListing(listingId: string): Promise<AirbnbListing> {\n  console.log(`[Sync Placeholder] Fetching Airbnb listing details for ID: ${listingId}`);\n  // TODO: Replace with actual API call to Airbnb.\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate network delay\n  return {\n    listingId: listingId,\n    isAvailable: true, // Assume available by default for placeholder\n    pricePerNight: 150, // Example price\n  };\n}\n\n/**\n * Asynchronously retrieves Booking.com listing details.\n * PLACEHOLDER IMPLEMENTATION. Requires actual Booking.com API call.\n *\n * @param listingId The Booking.com listing ID.\n * @returns A promise that resolves to a BookingComListing object.\n */\nexport async function getBookingComListing(listingId: string): Promise<BookingComListing> {\n  console.log(`[Sync Placeholder] Fetching Booking.com listing details for ID: ${listingId}`);\n  // TODO: Replace with actual API call to Booking.com.\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate network delay\n  return {\n    listingId: listingId,\n    isAvailable: true, // Assume available by default for placeholder\n    pricePerNight: 160, // Example price\n  };\n}\n\n/**\n * Updates Airbnb listing availability for a specific date range.\n * PLACEHOLDER IMPLEMENTATION. Requires actual Airbnb API call.\n * This simplified version only takes a boolean; a real implementation needs date range parameters.\n *\n * @param listingId The Airbnb listing ID.\n * @param isAvailable The new availability status (true for available, false for blocked).\n * @param checkInDate The start date of the range (optional).\n * @param checkOutDate The end date of the range (optional).\n * @returns A promise that resolves when the update attempt is complete.\n */\nexport async function updateAirbnbListingAvailability(\n    listingId: string,\n    isAvailable: boolean,\n    checkInDate?: Date,\n    checkOutDate?: Date\n): Promise<void> {\n  const dateRangeString = checkInDate && checkOutDate\n    ? ` from ${checkInDate.toISOString().split('T')[0]} to ${checkOutDate.toISOString().split('T')[0]}`\n    : '';\n  console.log(`[Sync Placeholder] Updating Airbnb listing ${listingId} availability to ${isAvailable}${dateRangeString}.`);\n  // TODO: Replace with actual API call to Airbnb, passing the specific date range to block/unblock.\n  await new Promise(resolve => setTimeout(resolve, 150)); // Simulate network delay\n  return;\n}\n\n/**\n * Updates Booking.com listing availability for a specific date range.\n * PLACEHOLDER IMPLEMENTATION. Requires actual Booking.com API call.\n * This simplified version only takes a boolean; a real implementation needs date range parameters.\n *\n * @param listingId The Booking.com listing ID.\n * @param isAvailable The new availability status (true for available, false for blocked).\n * @param checkInDate The start date of the range (optional).\n * @param checkOutDate The end date of the range (optional).\n * @returns A promise that resolves when the update attempt is complete.\n */\nexport async function updateBookingComListingAvailability(\n    listingId: string,\n    isAvailable: boolean,\n    checkInDate?: Date,\n    checkOutDate?: Date\n): Promise<void> {\n   const dateRangeString = checkInDate && checkOutDate\n     ? ` from ${checkInDate.toISOString().split('T')[0]} to ${checkOutDate.toISOString().split('T')[0]}`\n     : '';\n   console.log(`[Sync Placeholder] Updating Booking.com listing ${listingId} availability to ${isAvailable}${dateRangeString}.`);\n  // TODO: Replace with actual API call to Booking.com, passing the specific date range to block/unblock.\n  await new Promise(resolve => setTimeout(resolve, 150)); // Simulate network delay\n  return;\n}\n\n// TODO: Add functions for more granular sync (e.g., update price, minimum stay).\n// TODO: Implement webhook handlers to receive availability updates FROM external platforms.\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;AAGD;AAAA;AACA;;;;;;AA2BO,eAAe,uCAAgB,GAAhB,mBAAmB,UAAkB;IACvD,MAAM,cAAc,CAAA,GAAA,iKAAA,CAAA,MAAG,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,cAAc;IAC1C,IAAI;QACA,MAAM,UAAU,MAAM,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE;QAC7B,IAAI,QAAQ,MAAM,IAAI;YAClB,OAAO;gBAAE,IAAI,QAAQ,EAAE;gBAAE,GAAG,QAAQ,IAAI,EAAE;YAAC;QAC/C,OAAO;YACH,QAAQ,IAAI,CAAC,CAAC,0EAA0E,EAAE,YAAY;YACtG,OAAO;QACX;IACJ,EAAE,OAAO,OAAO;QACX,QAAQ,KAAK,CAAC,CAAC,+CAA+C,EAAE,WAAW,CAAC,CAAC,EAAE;QAC/E,OAAO;IACZ;AACJ;AAUO,eAAe,uCAAc,GAAd,iBAAiB,SAAiB;IACtD,QAAQ,GAAG,CAAC,CAAC,2DAA2D,EAAE,WAAW;IACrF,gDAAgD;IAChD,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,yBAAyB;IACjF,OAAO;QACL,WAAW;QACX,aAAa;QACb,eAAe;IACjB;AACF;AASO,eAAe,uCAAkB,GAAlB,qBAAqB,SAAiB;IAC1D,QAAQ,GAAG,CAAC,CAAC,gEAAgE,EAAE,WAAW;IAC1F,qDAAqD;IACrD,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,yBAAyB;IACjF,OAAO;QACL,WAAW;QACX,aAAa;QACb,eAAe;IACjB;AACF;AAaO,eAAe,uCAA6B,GAA7B,gCAClB,SAAiB,EACjB,WAAoB,EACpB,WAAkB,EAClB,YAAmB;IAErB,MAAM,kBAAkB,eAAe,eACnC,CAAC,MAAM,EAAE,YAAY,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,aAAa,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,GACjG;IACJ,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,UAAU,iBAAiB,EAAE,cAAc,gBAAgB,CAAC,CAAC;IACvH,kGAAkG;IAClG,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,yBAAyB;IACjF;AACF;AAaO,eAAe,uCAAiC,GAAjC,oCAClB,SAAiB,EACjB,WAAoB,EACpB,WAAkB,EAClB,YAAmB;IAEpB,MAAM,kBAAkB,eAAe,eACnC,CAAC,MAAM,EAAE,YAAY,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,aAAa,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,GACjG;IACJ,QAAQ,GAAG,CAAC,CAAC,gDAAgD,EAAE,UAAU,iBAAiB,EAAE,cAAc,gBAAgB,CAAC,CAAC;IAC7H,uGAAuG;IACvG,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,yBAAyB;IACjF;AACF,EAEA,iFAAiF;CACjF,4FAA4F;;;IA1GtE;IAwBA;IAkBA;IAsBA;IA0BA;;AA1FA,+OAAA;AAwBA,+OAAA;AAkBA,+OAAA;AAsBA,+OAAA;AA0BA,+OAAA","debugId":null}},
    {"offset": {"line": 282, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/bookingService.ts"],"sourcesContent":["// src/services/bookingService.ts\n'use server'; // Mark this module for server-side execution\n\nimport {\n  collection,\n  addDoc,\n  doc,\n  getDoc,\n  updateDoc,\n  query,\n  where,\n  getDocs,\n  serverTimestamp as clientServerTimestamp, // Rename client timestamp\n  Timestamp as ClientTimestamp, // Rename client timestamp\n  writeBatch as clientWriteBatch, // Rename client batch\n  setDoc as clientSetDoc, // Rename client setDoc\n  QueryConstraint,\n  limit,\n  documentId, // Import documentId for querying by ID\n} from 'firebase/firestore';\nimport { z } from 'zod';\nimport { db } from '@/lib/firebase'; // **** Use Client SDK Firestore instance ****\n// import { dbAdmin } from '@/lib/firebaseAdmin'; // No longer needed\nimport type { Booking, Availability, Property, SerializableTimestamp } from '@/types'; // Import SerializableTimestamp\nimport { differenceInCalendarDays, eachDayOfInterval, format, parse, subDays, startOfMonth, endOfMonth, parseISO } from 'date-fns';\nimport { updateAirbnbListingAvailability, updateBookingComListingAvailability, getPropertyForSync } from './booking-sync';\n\n// Define the structure for creating a booking\n// Aligning pricing with the updated Booking type\n// Export this type so it can be used by the simulation action\nexport type CreateBookingData = Omit<Booking,\n  'id' |\n  'checkInDate' |\n  'checkOutDate' |\n  'createdAt' |\n  'updatedAt' |\n  'paymentInfo' |\n  'pricing' // Pricing structure will be derived but needs explicit fields\n> & {\n  checkInDate: string; // ISO String for input\n  checkOutDate: string; // ISO String for input\n  pricing: { // Explicitly define expected input for pricing calc\n    baseRate: number;\n    numberOfNights: number;\n    cleaningFee: number;\n    extraGuestFee?: number; // From property at time of booking\n    numberOfExtraGuests?: number; // Calculated based on form input\n    accommodationTotal: number; // New field for base + extra guests cost\n    subtotal: number; // New field for accommodation + cleaning\n    taxes?: number; // Still optional\n    discountAmount?: number; // Optional: Amount discounted via coupon\n    total: number; // Final total calculated by the form/client\n  };\n  appliedCouponCode?: string; // Optional: Store the applied coupon code\n  paymentInput: {\n    stripePaymentIntentId: string;\n    amount: number;\n    status: string;\n  };\n};\n\n\n// Define Zod schema for validation - Updated pricing schema\nconst CreateBookingDataSchema = z.object({\n  propertyId: z.string().min(1, { message: 'Property ID is required.' }),\n  guestInfo: z.object({\n    firstName: z.string().min(1, { message: 'Guest first name is required.' }),\n    lastName: z.string().optional(),\n    email: z.string().email({ message: 'Invalid guest email address.' }),\n    phone: z.string().optional(),\n    address: z.string().optional(),\n    city: z.string().optional(),\n    state: z.string().optional(),\n    country: z.string().optional(),\n    zipCode: z.string().optional(),\n    userId: z.string().optional(),\n  }).passthrough(),\n   // Accept ISO string dates for validation\n  checkInDate: z.string().refine(val => !isNaN(Date.parse(val)), { message: 'Invalid check-in date format.' }),\n  checkOutDate: z.string().refine(val => !isNaN(Date.parse(val)), { message: 'Invalid check-out date format.' }),\n  numberOfGuests: z.number().int().positive({ message: 'Number of guests must be positive.' }),\n  pricing: z.object({ // Updated pricing validation\n    baseRate: z.number().nonnegative({ message: 'Base rate cannot be negative.' }), // Allow 0 for free stays? Adjusted to nonnegative\n    numberOfNights: z.number().int().positive({ message: 'Number of nights must be positive.' }),\n    cleaningFee: z.number().nonnegative({ message: 'Cleaning fee cannot be negative.' }),\n    extraGuestFee: z.number().nonnegative({ message: 'Extra guest fee cannot be negative.' }).optional(),\n    numberOfExtraGuests: z.number().int().nonnegative({ message: 'Number of extra guests cannot be negative.' }).optional(),\n    accommodationTotal: z.number().nonnegative({ message: 'Accommodation total cannot be negative.' }), // Adjusted to nonnegative\n    subtotal: z.number().nonnegative({ message: 'Subtotal cannot be negative.' }), // Adjusted to nonnegative\n    taxes: z.number().nonnegative({ message: 'Taxes cannot be negative.' }).optional(),\n    discountAmount: z.number().nonnegative({ message: 'Discount amount cannot be negative.' }).optional(),\n    total: z.number().nonnegative({ message: 'Total price cannot be negative.' }), // Adjusted to nonnegative\n  }).passthrough(),\n  appliedCouponCode: z.string().optional(), // Validate optional coupon code\n  status: z.enum(['pending', 'confirmed', 'cancelled', 'completed']).optional(),\n  paymentInput: z.object({\n    stripePaymentIntentId: z.string().min(1, { message: 'Stripe Payment Intent ID is required.' }),\n    amount: z.number().nonnegative({ message: 'Payment amount cannot be negative.' }), // Allow 0 for free/fully discounted? Adjusted to nonnegative\n    status: z.string().min(1, { message: 'Payment status is required.' }),\n  }).passthrough(),\n  notes: z.string().optional(),\n  source: z.string().optional(),\n  externalId: z.string().optional(),\n}).refine(data => new Date(data.checkOutDate) > new Date(data.checkInDate), {\n  message: 'Check-out date must be after check-in date.',\n  path: ['checkOutDate'],\n}).refine(data => { // Ensure total matches calculated price, allowing for minor float issues\n    const calculatedTotal = (data.pricing.subtotal ?? 0) + (data.pricing.taxes ?? 0) - (data.pricing.discountAmount ?? 0);\n    // Allow for small floating point differences (e.g., $0.01)\n    return Math.abs(calculatedTotal - data.pricing.total) < 0.01;\n}, {\n    message: 'Calculated total does not match provided total price.',\n    path: ['pricing.total'],\n});\n\n\n/**\n * Creates a new booking document in Firestore using the Client SDK.\n * Calls updatePropertyAvailability (which now also uses the Client SDK) upon success.\n */\nexport async function createBooking(rawBookingData: CreateBookingData): Promise<string> {\n   const paymentIntentId = rawBookingData?.paymentInput?.stripePaymentIntentId || 'N/A';\n   console.log(`--- [createBooking] Function called ---`);\n   console.log(`[createBooking] Received raw data for Payment Intent [${paymentIntentId}]`);\n\n   let bookingData: z.infer<typeof CreateBookingDataSchema>;\n\n   // Zod Validation\n   console.log(`[createBooking] Starting Zod validation for Payment Intent [${paymentIntentId}]...`);\n   const validationResult = CreateBookingDataSchema.safeParse(rawBookingData);\n   if (!validationResult.success) {\n     const errorMessages = validationResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');\n     const validationError = new Error(`Invalid booking data: ${errorMessages}`);\n     console.error(`❌ [createBooking] Validation Error for Payment Intent [${paymentIntentId}]:`, validationError.message);\n     throw validationError;\n   }\n   bookingData = validationResult.data;\n   console.log(`[createBooking] Data passed validation for Payment Intent [${paymentIntentId}]`);\n\n\n  try {\n     console.log(`[createBooking] Entered main try block for Payment Intent [${paymentIntentId}]`);\n     const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db' for booking creation\n\n     // Data Transformation\n     console.log(`[createBooking] Transforming data for Firestore for Payment Intent [${paymentIntentId}]...`);\n     const checkInDate = new Date(bookingData.checkInDate); // Parse ISO string\n     const checkOutDate = new Date(bookingData.checkOutDate); // Parse ISO string\n     const checkInTimestamp = ClientTimestamp.fromDate(checkInDate); // Use Client Timestamp\n     const checkOutTimestamp = ClientTimestamp.fromDate(checkOutDate); // Use Client Timestamp\n\n     const paymentInfo: Booking['paymentInfo'] = {\n       stripePaymentIntentId: bookingData.paymentInput.stripePaymentIntentId,\n       amount: bookingData.paymentInput.amount,\n       status: bookingData.paymentInput.status,\n       paidAt: bookingData.paymentInput.status === 'succeeded' || bookingData.paymentInput.status === 'paid'\n         ? ClientTimestamp.now() // Use Client Timestamp\n         : null,\n     };\n\n     // Remove paymentInput before creating the main docData\n     const { paymentInput, ...restOfBookingData } = bookingData;\n\n     // Construct the final booking document data, including the updated pricing structure\n     const docData: Omit<Booking, 'id'> = {\n         ...restOfBookingData,\n         checkInDate: checkInTimestamp,\n         checkOutDate: checkOutTimestamp,\n         pricing: { // Use the validated pricing object\n             baseRate: restOfBookingData.pricing.baseRate,\n             numberOfNights: restOfBookingData.pricing.numberOfNights,\n             cleaningFee: restOfBookingData.pricing.cleaningFee,\n             extraGuestFee: restOfBookingData.pricing.extraGuestFee,\n             numberOfExtraGuests: restOfBookingData.pricing.numberOfExtraGuests,\n             accommodationTotal: restOfBookingData.pricing.accommodationTotal,\n             subtotal: restOfBookingData.pricing.subtotal,\n             taxes: restOfBookingData.pricing.taxes ?? 0,\n             discountAmount: restOfBookingData.pricing.discountAmount, // Include discount amount\n             total: restOfBookingData.pricing.total,\n         },\n         appliedCouponCode: restOfBookingData.appliedCouponCode, // Include applied coupon code\n         paymentInfo: paymentInfo,\n         createdAt: clientServerTimestamp(), // Use Client serverTimestamp\n         updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n         status: restOfBookingData.status || 'confirmed', // Default status to 'confirmed'\n     };\n\n     // Log the prepared data for debugging\n     console.log(`[createBooking] Firestore Doc Data Prepared for Payment Intent [${paymentIntentId}]:`, JSON.stringify({ ...docData, checkInDate: `Timestamp(${checkInDate.toISOString()})`, checkOutDate: `Timestamp(${checkOutDate.toISOString()})`, paidAt: docData.paymentInfo.paidAt ? `Timestamp(${(docData.paymentInfo.paidAt as ClientTimestamp).toDate().toISOString()})` : null, createdAt: 'ServerTimestamp', updatedAt: 'ServerTimestamp' }, null, 2));\n\n\n     // Firestore Operation (Client SDK)\n     console.log(`[createBooking] Attempting to add booking document to Firestore (Client SDK) for Payment Intent [${paymentIntentId}]...`);\n     const docRef = await addDoc(bookingsCollection, docData);\n     const bookingId = docRef.id;\n     console.log(`✅ [createBooking] Booking document created successfully! ID: ${bookingId} for Payment Intent [${paymentIntentId}]`);\n\n     // --- Update Property Availability (Client SDK) ---\n     console.log(`[createBooking] Triggering local availability update (Client SDK) for property ${bookingData.propertyId}, booking ${bookingId}`);\n     try {\n       await updatePropertyAvailability(bookingData.propertyId, checkInDate, checkOutDate, false); // Using Client SDK function\n       console.log(`✅ [createBooking] Successfully finished update call for local availability (Client SDK) for property ${bookingData.propertyId}, booking ${bookingId}.`);\n     } catch (availabilityError) {\n       console.error(`❌ [createBooking] Failed to update local availability (Client SDK) for property ${bookingData.propertyId} after creating booking ${bookingId}:`, availabilityError);\n       // Decide if this should block the entire process or just log a warning\n       // Re-throwing the error might be safer if availability is critical\n       throw availabilityError; // Re-throw to indicate the overall process partially failed\n     }\n\n     // --- Synchronize Availability with External Platforms ---\n      console.log(`[createBooking] Starting external platform sync for property ${bookingData.propertyId}, booking ${bookingId}...`);\n      try {\n         const propertyDetails = await getPropertyForSync(bookingData.propertyId);\n         if (propertyDetails) {\n             if (propertyDetails.airbnbListingId) {\n                 await updateAirbnbListingAvailability(propertyDetails.airbnbListingId, false, checkInDate, checkOutDate);\n                 console.log(`[createBooking Sync] Initiated Airbnb availability update for listing ${propertyDetails.airbnbListingId}.`);\n             } else {\n                  console.log(`[createBooking Sync] No Airbnb Listing ID found for property ${bookingData.propertyId}. Skipping Airbnb sync.`);\n             }\n             if (propertyDetails.bookingComListingId) {\n                 await updateBookingComListingAvailability(propertyDetails.bookingComListingId, false, checkInDate, checkOutDate);\n                 console.log(`[createBooking Sync] Initiated Booking.com availability update for listing ${propertyDetails.bookingComListingId}.`);\n             } else {\n                  console.log(`[createBooking Sync] No Booking.com Listing ID found for property ${bookingData.propertyId}. Skipping Booking.com sync.`);\n             }\n         } else {\n              console.warn(`[createBooking Sync] Could not retrieve property details for ${bookingData.propertyId} to perform external sync.`);\n         }\n     } catch (syncError) {\n         console.error(`❌ [createBooking Sync] Error synchronizing availability with external platforms for property ${bookingData.propertyId} after creating booking ${bookingId}:`, syncError);\n         // Log this but don't necessarily fail the entire booking creation\n     }\n\n     console.log(`--- [createBooking] Function returning successfully with booking ID: ${bookingId} ---`);\n     return bookingId;\n\n   } catch (error) {\n      // Avoid logging validation errors twice\n      if (!(error instanceof Error && error.message.startsWith('Invalid booking data:'))) {\n          console.error(`❌ [createBooking] Error during booking creation process for Payment Intent [${paymentIntentId}]:`, error);\n      }\n     // Construct a user-friendly error message, hiding internal details unless it's a validation error\n     const errorMessage = error instanceof Error\n         ? (error.message.startsWith('Invalid booking data:') ? error.message : `Failed to create booking (Ref: ${paymentIntentId}). Please contact support.`) // More generic for other errors\n         : `An unexpected error occurred while creating the booking (Ref: ${paymentIntentId}). Please contact support.`;\n\n     throw new Error(errorMessage);\n   }\n }\n\n/**\n * Retrieves a booking document by its ID using the Client SDK.\n */\nexport async function getBookingById(bookingId: string): Promise<Booking | null> {\n    try {\n        const bookingRef = doc(db, 'bookings', bookingId); // Use Client SDK 'db'\n        const docSnap = await getDoc(bookingRef);\n\n        if (docSnap.exists()) {\n            const data = docSnap.data();\n            // Convert Timestamps if needed for client consumption, or keep as Timestamps\n            const bookingResult = {\n                id: docSnap.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n            } as Booking;\n            return bookingResult;\n        } else {\n            console.warn(`[getBookingById] No booking found with ID: ${bookingId}`);\n            return null;\n        }\n    } catch (error) {\n        console.error(`❌ [getBookingById] Error fetching booking with ID ${bookingId}:`, error);\n        throw new Error(`Failed to fetch booking: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Updates the status of a specific booking document using the Client SDK.\n * Calls updatePropertyAvailability (Client SDK) if status is 'cancelled'.\n */\nexport async function updateBookingStatus(bookingId: string, status: Booking['status']): Promise<void> {\n    try {\n        const bookingRef = doc(db, 'bookings', bookingId); // Use Client SDK 'db'\n        await updateDoc(bookingRef, {\n            status: status,\n            updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n        });\n        console.log(`✅ [updateBookingStatus] Successfully updated booking ${bookingId} to status: ${status}`);\n\n        if (status === 'cancelled') {\n          const booking = await getBookingById(bookingId); // Re-fetch using Client SDK\n          if (booking && booking.checkInDate && booking.checkOutDate) {\n            // Convert Client Timestamps back to Dates\n            const checkIn = (booking.checkInDate as ClientTimestamp).toDate();\n            const checkOut = (booking.checkOutDate as ClientTimestamp).toDate();\n            try {\n                // **** Call function using Client SDK ****\n                await updatePropertyAvailability(booking.propertyId, checkIn, checkOut, true);\n                console.log(`✅ [updateBookingStatus] Successfully updated local availability (Client SDK) for cancelled booking ${bookingId}.`);\n            } catch (availError) {\n                 console.error(`❌ [updateBookingStatus] Failed to update local availability (Client SDK) for cancelled booking ${bookingId}:`, availError);\n            }\n\n             // Trigger external sync\n             try {\n                const propertyDetails = await getPropertyForSync(booking.propertyId);\n                if (propertyDetails) {\n                    if (propertyDetails.airbnbListingId) {\n                        await updateAirbnbListingAvailability(propertyDetails.airbnbListingId, true, checkIn, checkOut);\n                         console.log(`[Sync] Initiated Airbnb date release for ${propertyDetails.airbnbListingId}`);\n                    }\n                     if (propertyDetails.bookingComListingId) {\n                        await updateBookingComListingAvailability(propertyDetails.bookingComListingId, true, checkIn, checkOut);\n                         console.log(`[Sync] Initiated Booking.com date release for ${propertyDetails.bookingComListingId}`);\n                    }\n                } else {\n                    console.warn(`[Sync] Could not find property details for ${booking.propertyId} to sync cancellation.`);\n                }\n             } catch (syncError) {\n                 console.error(`❌ [Sync] Error syncing availability after cancellation for booking ${bookingId}:`, syncError);\n             }\n          } else {\n             console.warn(`[updateBookingStatus] Could not find booking ${bookingId} or its dates to update availability after cancellation.`);\n          }\n        }\n\n    } catch (error) {\n        console.error(`❌ [updateBookingStatus] Error updating status for booking ${bookingId} (Client SDK):`, error);\n        throw new Error(`Failed to update booking status: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Retrieves all bookings associated with a specific property ID using the Client SDK.\n */\nexport async function getBookingsForProperty(propertyId: string): Promise<Booking[]> {\n    const bookings: Booking[] = [];\n    try {\n        const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db'\n        const q = query(bookingsCollection, where('propertyId', '==', propertyId));\n        const querySnapshot = await getDocs(q);\n\n        querySnapshot.forEach((doc) => {\n            const data = doc.data();\n            bookings.push({\n                id: doc.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n            } as Booking);\n        });\n        return bookings;\n    } catch (error) {\n        console.error(`❌ [getBookingsForProperty] Error fetching bookings for property ${propertyId}:`, error);\n        throw new Error(`Failed to fetch bookings for property: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n/**\n * Retrieves all bookings associated with a specific user ID using the Client SDK.\n */\nexport async function getBookingsForUser(userId: string): Promise<Booking[]> {\n     const bookings: Booking[] = [];\n    try {\n        const bookingsCollection = collection(db, 'bookings'); // Use Client SDK 'db'\n        const q = query(bookingsCollection, where('guestInfo.userId', '==', userId));\n        const querySnapshot = await getDocs(q);\n\n        querySnapshot.forEach((doc) => {\n             const data = doc.data();\n             bookings.push({\n                 id: doc.id,\n                ...data,\n                checkInDate: data.checkInDate, // Client Timestamp\n                checkOutDate: data.checkOutDate, // Client Timestamp\n                createdAt: data.createdAt, // Client Timestamp\n                updatedAt: data.updatedAt, // Client Timestamp\n                 paymentInfo: {\n                    ...data.paymentInfo,\n                    paidAt: data.paymentInfo?.paidAt, // Client Timestamp or null\n                },\n             } as Booking);\n        });\n        return bookings;\n    } catch (error) {\n        console.error(`❌ [getBookingsForUser] Error fetching bookings for user ${userId}:`, error);\n        throw new Error(`Failed to fetch bookings for user: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n\n/**\n * Updates the availability status for a given property and date range in Firestore\n * using the **Firebase Client SDK**.\n *\n * This function relies on Firestore security rules to allow the necessary writes.\n * It should be called from a trusted server environment (e.g., a Next.js server action)\n * that runs under an appropriate authentication context if required by the rules.\n */\nexport async function updatePropertyAvailability(propertyId: string, checkInDate: Date, checkOutDate: Date, available: boolean): Promise<void> {\n  console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function called ---`);\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Args: propertyId=${propertyId}, checkIn=${format(checkInDate, 'yyyy-MM-dd')}, checkOut=${format(checkOutDate, 'yyyy-MM-dd')} (exclusive), available=${available}`);\n\n  if (!db) {\n    console.error(\"❌ [updatePropertyAvailability - CLIENT SDK] Firestore Client SDK (db) is not initialized. Cannot update availability.\");\n    throw new Error(\"Firestore Client SDK is not initialized.\");\n  }\n\n  if (checkOutDate <= checkInDate) {\n    console.warn(`[updatePropertyAvailability] Check-out date (${format(checkOutDate, 'yyyy-MM-dd')}) must be after check-in date (${format(checkInDate, 'yyyy-MM-dd')}). No update performed.`);\n    return;\n  }\n\n  const datesToUpdate = eachDayOfInterval({\n    start: checkInDate,\n    end: subDays(checkOutDate, 1) // Make checkout date exclusive\n  });\n\n  if (datesToUpdate.length === 0) {\n    console.log(\"[updatePropertyAvailability - CLIENT SDK] No dates need updating.\");\n    return;\n  }\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Dates to update (${datesToUpdate.length}): ${datesToUpdate.map(d => format(d, 'yyyy-MM-dd')).join(', ')}`);\n\n  const updatesByMonth: { [month: string]: { [day: number]: boolean } } = {};\n  datesToUpdate.forEach(date => {\n    const monthStr = format(date, 'yyyy-MM');\n    const dayOfMonth = date.getDate();\n    if (!updatesByMonth[monthStr]) {\n      updatesByMonth[monthStr] = {};\n    }\n    updatesByMonth[monthStr][dayOfMonth] = available;\n  });\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Updates grouped by month:`, JSON.stringify(updatesByMonth));\n\n\n  const batch = clientWriteBatch(db); // Use clientWriteBatch with client db\n  const availabilityCollection = collection(db, 'availability'); // Use client db\n  console.log(`[updatePropertyAvailability - CLIENT SDK] Initialized Firestore Client batch.`);\n\n  try {\n    const monthStrings = Object.keys(updatesByMonth);\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Processing months: ${monthStrings.join(', ')}`);\n\n    if (monthStrings.length === 0) {\n      console.log(\"[updatePropertyAvailability - CLIENT SDK] No months to process.\");\n      return;\n    }\n\n    // Fetch existing docs using Client SDK 'in' query\n    const docIdsToFetch = monthStrings.map(monthStr => `${propertyId}_${monthStr}`);\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Fetching existing availability docs for ${monthStrings.length} months...`);\n\n    // Split into batches if necessary (max 30 IDs per 'in' query)\n    const idBatches: string[][] = [];\n    for (let i = 0; i < docIdsToFetch.length; i += 30) {\n      idBatches.push(docIdsToFetch.slice(i, i + 30));\n    }\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Split into ${idBatches.length} query batches due to 'in' operator limit.`);\n\n    const fetchedDocsMap = new Map<string, Availability>();\n    await Promise.all(idBatches.map(async (batchIds, index) => {\n      if (batchIds.length === 0) return;\n      console.log(`[updatePropertyAvailability - CLIENT SDK] Executing query for batch ${index + 1}: ${batchIds.join(', ')}`);\n      const q = query(availabilityCollection, where(documentId(), 'in', batchIds));\n      const querySnapshot = await getDocs(q);\n      querySnapshot.forEach(docSnap => {\n        if (docSnap.exists()) {\n          fetchedDocsMap.set(docSnap.id, { id: docSnap.id, ...docSnap.data() } as Availability);\n        }\n      });\n    }));\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Fetched ${fetchedDocsMap.size} existing doc snapshots.`);\n\n    monthStrings.forEach(monthStr => {\n      const availabilityDocId = `${propertyId}_${monthStr}`;\n      console.log(`[updatePropertyAvailability Batch Prep] Processing month ${monthStr} (Doc ID: ${availabilityDocId}). Updates needed for days: ${Object.keys(updatesByMonth[monthStr]).join(', ')}`);\n      const availabilityDocRef = doc(availabilityCollection, availabilityDocId); // Use client db\n      const updatesForDay = updatesByMonth[monthStr];\n\n      const updatePayload: { [key: string]: boolean | SerializableTimestamp } = {}; // Use SerializableTimestamp for serverTimestamp\n      for (const day in updatesForDay) {\n        updatePayload[`available.${String(day)}`] = updatesForDay[day];\n      }\n      updatePayload.updatedAt = clientServerTimestamp(); // Use Client serverTimestamp\n      console.log(`[updatePropertyAvailability Batch Prep] Prepared update payload for ${availabilityDocId}:`, JSON.stringify({ ...updatePayload, updatedAt: 'ServerTimestamp' }));\n\n\n      const existingDoc = fetchedDocsMap.get(availabilityDocId);\n\n      if (existingDoc) {\n        console.log(`[updatePropertyAvailability Batch Prep] Doc ${availabilityDocId} exists. Adding UPDATE operation to client batch.`);\n        batch.update(availabilityDocRef, updatePayload);\n      } else {\n        console.log(`[updatePropertyAvailability Batch Prep] Doc ${availabilityDocId} DOES NOT exist. Creating initial data for month ${monthStr}.`);\n        const [year, month] = monthStr.split('-').map(Number);\n        const daysInMonth = new Date(year, month, 0).getDate();\n        const initialAvailableMap: { [day: number]: boolean } = {};\n        for (let day = 1; day <= daysInMonth; day++) {\n          initialAvailableMap[day] = updatesForDay[day] !== undefined ? updatesForDay[day] : true; // Apply update if exists, else default to true\n        }\n        console.log(`[updatePropertyAvailability Batch Prep] Calculated initial availability map for ${daysInMonth} days in ${monthStr}.`);\n\n        const newDocData: Partial<Availability> = {\n          propertyId: propertyId,\n          month: monthStr,\n          available: initialAvailableMap,\n          updatedAt: clientServerTimestamp(), // Use Client serverTimestamp\n        };\n        console.log(`[updatePropertyAvailability Batch Prep] New doc data for ${availabilityDocId}:`, JSON.stringify({ ...newDocData, updatedAt: 'ServerTimestamp' }));\n        console.log(`[updatePropertyAvailability Batch Prep] Adding SET operation (merge: true) to client batch for ${availabilityDocId}.`);\n        batch.set(availabilityDocRef, newDocData, { merge: true }); // Use merge: true to avoid overwriting existing fields if any\n      }\n    });\n\n    // Commit the Client SDK batch write\n    console.log(`[updatePropertyAvailability - CLIENT SDK] Preparing to commit client batch for property ${propertyId}, months: ${monthStrings.join(', ')}...`);\n    await batch.commit();\n    console.log(`✅ [updatePropertyAvailability - CLIENT SDK] Successfully committed batch updates for local availability for property ${propertyId}.`);\n    console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function finished successfully ---`);\n\n\n  } catch (error) {\n    // This error might be due to Firestore security rules denying the write.\n    console.error(`❌ Error during Client SDK batch update/creation for property availability ${propertyId}:`, error);\n    console.log(`--- [updatePropertyAvailability - CLIENT SDK] Function throwing error ---`);\n    throw new Error(`Failed to update local property availability using Client SDK: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n\n/**\n * Fetches all unavailable dates for a given property within a reasonable future range\n * using the **Client SDK**.\n */\nexport async function getUnavailableDatesForProperty(propertyId: string, monthsToFetch: number = 12): Promise<Date[]> {\n  const unavailableDates: Date[] = [];\n  console.log(`--- [getUnavailableDatesForProperty] Function called ---`);\n  console.log(`[getUnavailableDatesForProperty] Fetching for property ${propertyId} for the next ${monthsToFetch} months.`);\n\n  if (!db) {\n      console.error(\"❌ [getUnavailableDatesForProperty] Firestore Client SDK (db) is not initialized. Cannot fetch availability.\");\n      return []; // Return empty array if DB not ready\n  }\n\n  const availabilityCollection = collection(db, 'availability'); // Use Client SDK 'db'\n  const today = new Date();\n  // Use UTC for consistency when dealing with dates across potential timezones\n  const currentMonthStart = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));\n  console.log(`[getUnavailableDatesForProperty] Today (UTC): ${today.toISOString()}, Current Month Start (UTC): ${currentMonthStart.toISOString()}`);\n\n\n  try {\n    const monthDocIds: string[] = [];\n    for (let i = 0; i < monthsToFetch; i++) {\n      // Calculate target month correctly in UTC\n      const targetMonth = new Date(Date.UTC(currentMonthStart.getUTCFullYear(), currentMonthStart.getUTCMonth() + i, 1));\n      const monthStr = format(targetMonth, 'yyyy-MM');\n      monthDocIds.push(`${propertyId}_${monthStr}`);\n    }\n    console.log(`[getUnavailableDatesForProperty] Querying for document IDs: ${monthDocIds.join(', ')}`);\n\n\n    const queryBatches: string[][] = [];\n    for (let i = 0; i < monthDocIds.length; i += 30) { // Firestore 'in' query supports up to 30 elements\n        queryBatches.push(monthDocIds.slice(i, i + 30));\n    }\n    console.log(`[getUnavailableDatesForProperty] Split into ${queryBatches.length} query batches due to 'in' operator limit.`);\n\n     if (monthDocIds.length === 0) {\n        console.log(\"[getUnavailableDatesForProperty] No month document IDs to query. Returning empty array.\");\n        return [];\n    }\n\n    // Execute queries using Client SDK\n    const allQuerySnapshots = await Promise.all(\n      queryBatches.map(async (batchIds, index) => {\n          console.log(`[getUnavailableDatesForProperty] Executing query for batch ${index + 1}: ${batchIds.join(', ')}`);\n          const q = query(availabilityCollection, where(documentId(), 'in', batchIds)); // Use documentId() for client query\n          return getDocs(q);\n      })\n    );\n    console.log(`[getUnavailableDatesForProperty] Fetched results from ${allQuerySnapshots.length} batches.`);\n\n\n    allQuerySnapshots.forEach((querySnapshot, batchIndex) => {\n         console.log(`[getUnavailableDatesForProperty] Processing batch ${batchIndex + 1}: Found ${querySnapshot.docs.length} documents.`);\n         querySnapshot.forEach((doc) => {\n            const data = doc.data() as Partial<Availability>;\n            const docId = doc.id;\n            console.log(`[getUnavailableDatesForProperty] Processing doc: ${docId}`);\n            const monthStrFromId = docId.split('_')[1];\n            const monthStrFromData = data.month;\n            // Prefer month from data if available, fallback to parsing from ID\n            const monthStr = monthStrFromData || monthStrFromId;\n\n             if (!monthStr || !/^\\d{4}-\\d{2}$/.test(monthStr)) {\n                 console.warn(`[getUnavailableDatesForProperty] Could not determine valid month string for doc ${docId}. Skipping.`);\n                 return;\n             }\n\n            if (data.available && typeof data.available === 'object') {\n                const [year, monthIndex] = monthStr.split('-').map(num => parseInt(num, 10));\n                const month = monthIndex - 1; // JS months are 0-indexed\n                 console.log(`[getUnavailableDatesForProperty] Doc ${docId} (Month: ${monthStr}): Processing availability map...`);\n\n                for (const dayStr in data.available) {\n                    const day = parseInt(dayStr, 10);\n                    if (!isNaN(day) && data.available[day] === false) {\n                        try {\n                            if (year > 0 && month >= 0 && month < 12 && day > 0 && day <= 31) {\n                                const date = new Date(Date.UTC(year, month, day)); // Work in UTC\n                                 if (date.getUTCFullYear() === year && date.getUTCMonth() === month && date.getUTCDate() === day) {\n                                    const todayUtcStart = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));\n                                    if (date >= todayUtcStart) {\n                                        console.log(`   - Found unavailable date: ${format(date, 'yyyy-MM-dd')}`);\n                                        unavailableDates.push(date);\n                                    } else {\n                                        console.log(`   - Found past unavailable date: ${format(date, 'yyyy-MM-dd')}. Ignoring.`);\n                                    }\n                                 } else {\n                                     console.warn(`[getUnavailableDatesForProperty] Invalid date created for ${year}-${monthStr}-${dayStr} in doc ${docId}. Skipping.`);\n                                 }\n                            } else {\n                                 console.warn(`[getUnavailableDatesForProperty] Invalid year/month/day components found in doc ${docId}: year=${year}, month=${monthIndex}, day=${dayStr}. Skipping.`);\n                            }\n                        } catch (dateError) {\n                             console.warn(`[getUnavailableDatesForProperty] Error creating date for ${year}-${monthStr}-${dayStr} in doc ${docId}:`, dateError, `. Skipping.`);\n                        }\n                    }\n                }\n            } else {\n                 console.warn(`[getUnavailableDatesForProperty] Document ${docId} has missing or invalid 'available' data. Skipping.`);\n            }\n        });\n    });\n\n    unavailableDates.sort((a, b) => a.getTime() - b.getTime());\n    console.log(`[getUnavailableDatesForProperty] Total unavailable dates found for property ${propertyId}: ${unavailableDates.length}`);\n    console.log(`[getUnavailableDatesForProperty] Returning sorted unavailable dates: ${unavailableDates.map(d => format(d, 'yyyy-MM-dd')).join(', ')}`);\n    console.log(`--- [getUnavailableDatesForProperty] Function finished successfully ---`);\n    return unavailableDates;\n\n  } catch (error) {\n    console.error(`❌ Error fetching unavailable dates for property ${propertyId}:`, error);\n    console.log(`--- [getUnavailableDatesForProperty] Function finished with error ---`);\n    return []; // Return empty array on error\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions/simulate-webhook-success.ts"],"sourcesContent":["\"use server\";\n\nimport { z } from 'zod';\nimport { createBooking, type CreateBookingData } from \"@/services/bookingService\";\nimport type { Booking } from '@/types'; // Import Booking type\nimport { getDoc, doc, Timestamp } from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\n\n// Schema to validate input parameters from the success page URL\nconst SimulationInputSchema = z.object({\n  sessionId: z.string().min(1),\n  propertyId: z.string().min(1),\n  checkInDate: z.string().datetime(),\n  checkOutDate: z.string().datetime(),\n  numberOfGuests: z.coerce.number().int().positive(),\n  numberOfNights: z.coerce.number().int().positive(),\n  totalPrice: z.coerce.number().positive(),\n  appliedCouponCode: z.string().optional(),\n  discountPercentage: z.coerce.number().optional(),\n});\n\nexport async function simulateWebhookSuccess(\n  params: unknown // Accept unknown first for safe parsing\n): Promise<{ success: boolean; bookingId?: string; error?: string }> {\n\n  console.log('[Simulate Webhook] Action called.');\n\n  // Only run in development environment\n  if (process.env.NODE_ENV !== 'development') {\n    console.warn('[Simulate Webhook] Attempted to run simulation in non-development environment. Aborting.');\n    return { success: false, error: 'Simulation only allowed in development.' };\n  }\n\n  // Validate input parameters\n  const validationResult = SimulationInputSchema.safeParse(params);\n  if (!validationResult.success) {\n    const errorMessages = validationResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');\n    console.error('[Simulate Webhook] Invalid input parameters:', errorMessages);\n    return { success: false, error: `Invalid simulation parameters: ${errorMessages}` };\n  }\n\n  const {\n    sessionId,\n    propertyId,\n    checkInDate,\n    checkOutDate,\n    numberOfGuests,\n    numberOfNights,\n    totalPrice, // This is the final price received from the URL\n    appliedCouponCode,\n    discountPercentage,\n  } = validationResult.data;\n\n  console.log(`[Simulate Webhook] Processing simulation for Session ID: ${sessionId}, Property ID: ${propertyId}`);\n\n  try {\n    // 1. Fetch Property Details (needed for pricing calculation)\n    console.log(`[Simulate Webhook] Fetching property details for ID: ${propertyId}`);\n    const propertyRef = doc(db, 'properties', propertyId);\n    const propertySnap = await getDoc(propertyRef);\n    if (!propertySnap.exists()) {\n      throw new Error(`Property with ID ${propertyId} not found for simulation.`);\n    }\n    const propertyData = propertySnap.data();\n    console.log('[Simulate Webhook] Property data fetched:', propertyData);\n\n    const baseRate = propertyData.pricePerNight ?? 0;\n    const cleaningFee = propertyData.cleaningFee ?? 0;\n    const extraGuestFee = propertyData.extraGuestFee ?? 0;\n    const baseOccupancy = propertyData.baseOccupancy ?? 1;\n\n    // 2. Reconstruct Pricing Details (crucial step, must match createBooking expectations)\n    console.log('[Simulate Webhook] Reconstructing pricing details...');\n    const numberOfExtraGuests = Math.max(0, numberOfGuests - baseOccupancy);\n    const accommodationTotal = (baseRate * numberOfNights) + (extraGuestFee * numberOfExtraGuests * numberOfNights);\n    const subtotal = accommodationTotal + cleaningFee;\n    const discountAmount = discountPercentage ? subtotal * (discountPercentage / 100) : 0;\n\n    // VERY IMPORTANT: Ensure the totalPrice used in the mock matches the one from the URL params\n    // Calculate taxes based on the difference, but ensure the total matches.\n    const calculatedTotalBeforeTax = subtotal - discountAmount;\n    const taxes = Math.max(0, totalPrice - calculatedTotalBeforeTax); // Derive taxes\n\n    console.log(`[Simulate Webhook Pricing] BaseRate: ${baseRate}, Nights: ${numberOfNights}, ExtraGuests: ${numberOfExtraGuests}, ExtraFee: ${extraGuestFee}`);\n    console.log(`[Simulate Webhook Pricing] AccommodationTotal: ${accommodationTotal}, CleaningFee: ${cleaningFee}, Subtotal: ${subtotal}`);\n    console.log(`[Simulate Webhook Pricing] Discount: ${discountAmount} (${discountPercentage}%), Taxes (derived): ${taxes}`);\n    console.log(`[Simulate Webhook Pricing] Final Calculated Total (for validation): ${calculatedTotalBeforeTax + taxes}`);\n    console.log(`[Simulate Webhook Pricing] Final Total from URL (used): ${totalPrice}`);\n\n\n    // 3. Construct Mock Booking Data\n    console.log('[Simulate Webhook] Constructing mock booking data...');\n    const mockBookingData: CreateBookingData = {\n      propertyId: propertyId,\n      guestInfo: { // Using generic mock data for guest info\n        firstName: \"DevSim\",\n        lastName: \"User\",\n        email: `devsim_${Date.now()}@example.com`,\n        userId: \"dev-sim-user\",\n        phone: \"+15559998877\", // Example phone\n      },\n      checkInDate: checkInDate,\n      checkOutDate: checkOutDate,\n      numberOfGuests: numberOfGuests,\n      pricing: { // Ensure this matches the structure expected by createBooking\n        baseRate: baseRate,\n        numberOfNights: numberOfNights,\n        cleaningFee: cleaningFee,\n        extraGuestFee: extraGuestFee,\n        numberOfExtraGuests: numberOfExtraGuests,\n        accommodationTotal: accommodationTotal,\n        subtotal: subtotal,\n        taxes: taxes, // Use derived taxes\n        discountAmount: discountAmount, // Use calculated discount\n        total: totalPrice, // *** USE THE TOTAL PRICE FROM URL PARAMS ***\n      },\n      appliedCouponCode: appliedCouponCode,\n      paymentInput: {\n        stripePaymentIntentId: `sim_${sessionId}`, // Indicate simulation\n        amount: totalPrice, // Use the final total price from params\n        status: \"succeeded\", // Simulate success\n      },\n      status: 'confirmed' as Booking['status'], // Directly set status\n      source: 'dev-simulation',\n      notes: `Simulated booking via success page for session ${sessionId}.`,\n    };\n\n    console.log('[Simulate Webhook] Mock booking data constructed:', JSON.stringify(mockBookingData, null, 2));\n\n    // 4. Call createBooking\n    console.log('[Simulate Webhook] Calling createBooking...');\n    const bookingId = await createBooking(mockBookingData);\n    console.log(`[Simulate Webhook] createBooking finished. Booking ID: ${bookingId}`);\n\n    return { success: true, bookingId: bookingId };\n\n  } catch (error) {\n    console.error(`❌ [Simulate Webhook] Error during simulation for session ${sessionId}:`, error);\n    // Provide a more specific error message from the caught error\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return { success: false, error: `Simulation failed: ${errorMessage}` };\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;AAAA;AACA;;;;;;;;AAEA,gEAAgE;AAChE,MAAM,wBAAwB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrC,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IAC1B,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IAC3B,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IACjC,gBAAgB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ;IAChD,gBAAgB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ;IAChD,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ;IACtC,mBAAmB,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IACtC,oBAAoB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ;AAChD;AAEO,eAAe,uCAAoB,GAApB,uBACpB,MAAe,AAAC,wCAAwC;;IAGxD,QAAQ,GAAG,CAAC;IAEZ,sCAAsC;IACtC,uCAA4C;;IAG5C;IAEA,4BAA4B;IAC5B,MAAM,mBAAmB,sBAAsB,SAAS,CAAC;IACzD,IAAI,CAAC,iBAAiB,OAAO,EAAE;QAC7B,MAAM,gBAAgB,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,OAAO,EAAE,EAAE,IAAI,CAAC;QACvG,QAAQ,KAAK,CAAC,gDAAgD;QAC9D,OAAO;YAAE,SAAS;YAAO,OAAO,CAAC,+BAA+B,EAAE,eAAe;QAAC;IACpF;IAEA,MAAM,EACJ,SAAS,EACT,UAAU,EACV,WAAW,EACX,YAAY,EACZ,cAAc,EACd,cAAc,EACd,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EACnB,GAAG,iBAAiB,IAAI;IAEzB,QAAQ,GAAG,CAAC,CAAC,yDAAyD,EAAE,UAAU,eAAe,EAAE,YAAY;IAE/G,IAAI;QACF,6DAA6D;QAC7D,QAAQ,GAAG,CAAC,CAAC,qDAAqD,EAAE,YAAY;QAChF,MAAM,cAAc,CAAA,GAAA,iKAAA,CAAA,MAAG,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,cAAc;QAC1C,MAAM,eAAe,MAAM,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE;QAClC,IAAI,CAAC,aAAa,MAAM,IAAI;YAC1B,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,WAAW,0BAA0B,CAAC;QAC5E;QACA,MAAM,eAAe,aAAa,IAAI;QACtC,QAAQ,GAAG,CAAC,6CAA6C;QAEzD,MAAM,WAAW,aAAa,aAAa,IAAI;QAC/C,MAAM,cAAc,aAAa,WAAW,IAAI;QAChD,MAAM,gBAAgB,aAAa,aAAa,IAAI;QACpD,MAAM,gBAAgB,aAAa,aAAa,IAAI;QAEpD,uFAAuF;QACvF,QAAQ,GAAG,CAAC;QACZ,MAAM,sBAAsB,KAAK,GAAG,CAAC,GAAG,iBAAiB;QACzD,MAAM,qBAAqB,AAAC,WAAW,iBAAmB,gBAAgB,sBAAsB;QAChG,MAAM,WAAW,qBAAqB;QACtC,MAAM,iBAAiB,qBAAqB,WAAW,CAAC,qBAAqB,GAAG,IAAI;QAEpF,6FAA6F;QAC7F,yEAAyE;QACzE,MAAM,2BAA2B,WAAW;QAC5C,MAAM,QAAQ,KAAK,GAAG,CAAC,GAAG,aAAa,2BAA2B,eAAe;QAEjF,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,SAAS,UAAU,EAAE,eAAe,eAAe,EAAE,oBAAoB,YAAY,EAAE,eAAe;QAC1J,QAAQ,GAAG,CAAC,CAAC,+CAA+C,EAAE,mBAAmB,eAAe,EAAE,YAAY,YAAY,EAAE,UAAU;QACtI,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,eAAe,EAAE,EAAE,mBAAmB,qBAAqB,EAAE,OAAO;QACxH,QAAQ,GAAG,CAAC,CAAC,oEAAoE,EAAE,2BAA2B,OAAO;QACrH,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,YAAY;QAGnF,iCAAiC;QACjC,QAAQ,GAAG,CAAC;QACZ,MAAM,kBAAqC;YACzC,YAAY;YACZ,WAAW;gBACT,WAAW;gBACX,UAAU;gBACV,OAAO,CAAC,OAAO,EAAE,KAAK,GAAG,GAAG,YAAY,CAAC;gBACzC,QAAQ;gBACR,OAAO;YACT;YACA,aAAa;YACb,cAAc;YACd,gBAAgB;YAChB,SAAS;gBACP,UAAU;gBACV,gBAAgB;gBAChB,aAAa;gBACb,eAAe;gBACf,qBAAqB;gBACrB,oBAAoB;gBACpB,UAAU;gBACV,OAAO;gBACP,gBAAgB;gBAChB,OAAO;YACT;YACA,mBAAmB;YACnB,cAAc;gBACZ,uBAAuB,CAAC,IAAI,EAAE,WAAW;gBACzC,QAAQ;gBACR,QAAQ;YACV;YACA,QAAQ;YACR,QAAQ;YACR,OAAO,CAAC,+CAA+C,EAAE,UAAU,CAAC,CAAC;QACvE;QAEA,QAAQ,GAAG,CAAC,qDAAqD,KAAK,SAAS,CAAC,iBAAiB,MAAM;QAEvG,wBAAwB;QACxB,QAAQ,GAAG,CAAC;QACZ,MAAM,YAAY,MAAM,CAAA,GAAA,iIAAA,CAAA,gBAAa,AAAD,EAAE;QACtC,QAAQ,GAAG,CAAC,CAAC,uDAAuD,EAAE,WAAW;QAEjF,OAAO;YAAE,SAAS;YAAM,WAAW;QAAU;IAE/C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,yDAAyD,EAAE,UAAU,CAAC,CAAC,EAAE;QACxF,8DAA8D;QAC9D,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QACrE,OAAO;YAAE,SAAS;YAAO,OAAO,CAAC,mBAAmB,EAAE,cAAc;QAAC;IACvE;AACF;;;IAzHsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 1041, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/booking/success/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/booking/success/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/booking/success/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoS,GACjU,kEACA","debugId":null}},
    {"offset": {"line": 1106, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/booking/success/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/booking/success/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/booking/success/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgR,GAC7S,8CACA","debugId":null}},
    {"offset": {"line": 1120, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}